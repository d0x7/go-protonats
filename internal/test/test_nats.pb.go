// Code generated by protoc-gen-go-nats. DO NOT EDIT.
// Versions:
// - protoc-gen-go-nats v0.1.9-dev.2+dirty
// - protoc        v5.29.3
// source: test.proto

package test

import (
	context "context"
	json "encoding/json"
	errors "errors"
	fmt "fmt"
	nats_go "github.com/nats-io/nats.go"
	micro "github.com/nats-io/nats.go/micro"
	nuid "github.com/nats-io/nuid"
	proto "google.golang.org/protobuf/proto"
	slog "log/slog"
	sync "sync"
	time "time"
	go_nats "xiam.li/go-nats"
	impl "xiam.li/go-nats/impl"
)

// region Client
type TestServiceNATSClient interface {
	// Normal tests
	NormalTestTest(req *Test, opts ...go_nats.CallOption) (*Test, error)
	NormalEmptyTest(opts ...go_nats.CallOption) (*Test, error)
	NormalTestEmpty(req *Test, opts ...go_nats.CallOption) error
	NormalEmptyEmpty(opts ...go_nats.CallOption) error
	// Methods that will expect an error in the test implementation
	ErrServiceError(req *Test, opts ...go_nats.CallOption) (*Test, error)
	ErrServerError(req *Test, opts ...go_nats.CallOption) (*Test, error)
	ErrServiceErrorBroadcast(req *Test, opts ...go_nats.CallOption) ([]*Test, []go_nats.ServiceError, error)
	ErrServerErrorBroadcast(req *Test, opts ...go_nats.CallOption) ([]*Test, []go_nats.ServiceError, error)
	// Normal tests with broadcast option
	NormalBroadcastTestTest(req *Test, opts ...go_nats.CallOption) ([]*Test, []go_nats.ServiceError, error)
	NormalBroadcastEmptyTest(opts ...go_nats.CallOption) ([]*Test, []go_nats.ServiceError, error)
	NormalBroadcastTestEmpty(req *Test, opts ...go_nats.CallOption) ([]go_nats.ServiceError, error)
	NormalBroadcastEmptyEmpty(opts ...go_nats.CallOption) ([]go_nats.ServiceError, error)
	// Leader option tests
	LeaderOnlyTestTest(req *Test, opts ...go_nats.CallOption) (*Test, error)
	LeaderOnlyEmptyTest(opts ...go_nats.CallOption) (*Test, error)
	LeaderOnlyTestEmpty(req *Test, opts ...go_nats.CallOption) error
	LeaderOnlyEmptyEmpty(opts ...go_nats.CallOption) error
	// Leader with broadcast option tests
	LeaderOnlyBroadcastTestTest(req *Test, opts ...go_nats.CallOption) ([]*Test, []go_nats.ServiceError, error)
	LeaderOnlyBroadcastEmptyTest(opts ...go_nats.CallOption) ([]*Test, []go_nats.ServiceError, error)
	LeaderOnlyBroadcastTestEmpty(req *Test, opts ...go_nats.CallOption) ([]go_nats.ServiceError, error)
	LeaderOnlyBroadcastEmptyEmpty(opts ...go_nats.CallOption) ([]go_nats.ServiceError, error)
	// Follower option tests
	FollowerOnlyTestTest(req *Test, opts ...go_nats.CallOption) (*Test, error)
	FollowerOnlyEmptyTest(opts ...go_nats.CallOption) (*Test, error)
	FollowerOnlyTestEmpty(req *Test, opts ...go_nats.CallOption) error
	FollowerOnlyEmptyEmpty(opts ...go_nats.CallOption) error
	// Follower with broadcast option tests
	FollowerOnlyBroadcastTestTest(req *Test, opts ...go_nats.CallOption) ([]*Test, []go_nats.ServiceError, error)
	FollowerOnlyBroadcastEmptyTest(opts ...go_nats.CallOption) ([]*Test, []go_nats.ServiceError, error)
	FollowerOnlyBroadcastTestEmpty(req *Test, opts ...go_nats.CallOption) ([]go_nats.ServiceError, error)
	FollowerOnlyBroadcastEmptyEmpty(opts ...go_nats.CallOption) ([]go_nats.ServiceError, error)
	SetTimeout(time.Duration)
	// ListInstances returns a list containing all instances of this service
	// This is a convenience method that calls go_nats.Ping with no options
	ListInstances() ([]*go_nats.Ping, error)
	// Ping sends a ping to either all instances or a specific instance of this service
	Ping(opts ...go_nats.CallOption) ([]*go_nats.Ping, error)
	// Stats returns the stats of either all instances or a specific instance of this service
	Stats(opts ...go_nats.CallOption) ([]*micro.Stats, error)
	// Info returns the info of either all instances or a specific instance of this service
	Info(opts ...go_nats.CallOption) ([]*micro.Info, error)
}

type testServiceNATSClient struct {
	nc      *nats_go.Conn
	timeout time.Duration
}

func (c *testServiceNATSClient) SetTimeout(timeout time.Duration) {
	c.timeout = timeout
}

func (c *testServiceNATSClient) ListInstances() ([]*go_nats.Ping, error) {
	return c.Ping()
}

func (c *testServiceNATSClient) Stats(opts ...go_nats.CallOption) ([]*micro.Stats, error) {
	options := impl.ProcessCallOptions(opts...)
	timeout := options.GetTimeoutOr(c.timeout)

	var subject string
	if options.HasInstanceID() {
		subject = fmt.Sprintf("%s.%s.%s.%s", micro.APIPrefix, micro.StatsVerb, "TestService", options.InstanceID)
	} else {
		subject = fmt.Sprintf("%s.%s.%s", micro.APIPrefix, micro.StatsVerb, "TestService")
	}
	objs, _, err := request(c.nc, timeout, options.DisableFinisher, subject, nil, func(data []byte, rtt time.Duration) (*micro.Stats, error) {
		var obj micro.Stats
		if err := json.Unmarshal(data, &obj); err != nil {
			return nil, err
		}
		return &obj, nil
	})
	return objs, err
}

func (c *testServiceNATSClient) Info(opts ...go_nats.CallOption) ([]*micro.Info, error) {
	options := impl.ProcessCallOptions(opts...)
	timeout := options.GetTimeoutOr(c.timeout)

	var subject string
	if options.HasInstanceID() {
		subject = fmt.Sprintf("%s.%s.%s.%s", micro.APIPrefix, micro.InfoVerb, "TestService", options.InstanceID)
	} else {
		subject = fmt.Sprintf("%s.%s.%s", micro.APIPrefix, micro.InfoVerb, "TestService")
	}
	objs, _, err := request(c.nc, timeout, options.DisableFinisher, subject, nil, func(data []byte, rtt time.Duration) (*micro.Info, error) {
		var obj micro.Info
		if err := json.Unmarshal(data, &obj); err != nil {
			return nil, err
		}
		return &obj, nil
	})
	return objs, err
}

func (c *testServiceNATSClient) Ping(opts ...go_nats.CallOption) ([]*go_nats.Ping, error) {
	options := impl.ProcessCallOptions(opts...)
	timeout := options.GetTimeoutOr(c.timeout)

	var subject string
	if options.HasInstanceID() {
		subject = fmt.Sprintf("%s.%s.%s.%s", micro.APIPrefix, micro.PingVerb, "TestService", options.InstanceID)
	} else {
		subject = fmt.Sprintf("%s.%s.%s", micro.APIPrefix, micro.PingVerb, "TestService")
	}
	objs, _, err := request(c.nc, timeout, options.DisableFinisher, subject, nil, func(data []byte, rtt time.Duration) (*go_nats.Ping, error) {
		var obj go_nats.Ping
		if err := json.Unmarshal(data, &obj); err != nil {
			return nil, err
		}
		obj.RTT = rtt
		return &obj, nil
	})
	return objs, err
}

func (c *testServiceNATSClient) handleWithRetry(req proto.Message, subject string, out proto.Message, opts ...go_nats.CallOption) (err error) {
	options := impl.ProcessCallOptions(opts...)
	timeout := options.GetTimeoutOr(c.timeout)

	var tries int
	for {
		if options.HasInstanceID() {
			err = c.handle(req, subject+"."+options.InstanceID, out, timeout)
		} else {
			err = c.handle(req, subject, out, timeout)
		}
		if err == nil || !errors.Is(err, nats_go.ErrNoResponders) {
			return
		}
		tries++
		if options.RetryContext.Err() != nil {
			err = errors.Join(err, options.RetryContext.Err())
			return
		}
		if !options.ShouldRetry() {
			return
		}
		if tries >= options.Retries {
			err = errors.New("Failed to call service after max tries: " + err.Error())
			return
		}
		time.Sleep(options.RetryDelay)
	}
}
func (c *testServiceNATSClient) handle(req proto.Message, subject string, out proto.Message, timeout time.Duration) (err error) {
	var data []byte
	if req != nil {
		if data, err = proto.Marshal(req); err != nil {
			return go_nats.ErrMarshallingFailed
		}
	}
	msg, err := c.nc.Request(subject, data, timeout)
	if err != nil {
		return err
	}
	if errMsg, errCode := msg.Header.Get(micro.ErrorHeader), msg.Header.Get(micro.ErrorCodeHeader); len(errMsg) > 0 && len(errCode) > 0 {
		if len(msg.Data) == 0 {
			return go_nats.ServiceError{errCode, errMsg, ""}
		}
		return go_nats.ServiceError{errCode, errMsg, string(msg.Data)}
	}
	if out != nil {
		if err = proto.Unmarshal(msg.Data, out); err != nil {
			return go_nats.ErrUnmarshallingFailed
		}
	}
	return nil
}

func request[T any](conn *nats_go.Conn, timeout time.Duration, disableFinisher bool, subject string, data []byte, collector func([]byte, time.Duration) (*T, error)) ([]*T, []go_nats.ServiceError, error) {
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()

	timer := time.NewTimer(timeout)
	go func() {
		select {
		case <-timer.C:
			cancel()
		case <-ctx.Done():
			timer.Stop()
			return
		}
	}()
	var start time.Time
	res := []*T{}
	mu := sync.Mutex{}
	errCh := make(chan error)
	serviceErrs := []go_nats.ServiceError{}
	var finisher *time.Timer
	if !disableFinisher {
		finisher = time.NewTimer(timeout)
		go func() {
			select {
			case <-finisher.C:
				cancel()
			case <-ctx.Done():
				return
			}
		}()
	}
	sub, err := conn.Subscribe(conn.NewRespInbox(), func(msg *nats_go.Msg) {
		mu.Lock()
		defer mu.Unlock()

		rtt := time.Since(start)
		if msg.Header.Get("Status") == "503" {
			errCh <- nats_go.ErrNoResponders
			return
		}

		if finisher != nil {
			finisher.Reset(250 * time.Millisecond)
		}

		if errMsg, errCode := msg.Header.Get(micro.ErrorHeader), msg.Header.Get(micro.ErrorCodeHeader); len(errMsg) > 0 && len(errCode) > 0 {
			if len(msg.Data) == 0 {
				serviceErrs = append(serviceErrs, go_nats.ServiceError{Code: errCode, Description: errMsg})
			} else {
				serviceErrs = append(serviceErrs, go_nats.ServiceError{Code: errCode, Description: errMsg, Details: string(msg.Data)})
			}
			return
		}
		if collector != nil {
			if col, err := collector(msg.Data, rtt); err != nil {
				errCh <- err
			} else {
				res = append(res, col)
			}
		}
	})
	if err != nil {
		return nil, nil, err
	}
	defer sub.Unsubscribe()

	start = time.Now()
	err = conn.PublishRequest(subject, sub.Subject, data)
	if err != nil {
		return nil, nil, err
	}

	select {
	case err = <-errCh:
		return nil, serviceErrs, err
	case <-ctx.Done():
		return res, serviceErrs, nil
	}
}

func NewTestServiceNATSClient(nc *nats_go.Conn) TestServiceNATSClient {
	return &testServiceNATSClient{nc: nc, timeout: time.Second * 5}
}

func (c *testServiceNATSClient) NormalTestTest(req *Test, opts ...go_nats.CallOption) (*Test, error) {
	var response Test

	if err := c.handleWithRetry(req, "service.TestService.NormalTestTest", &response, opts...); err != nil {
		return nil, err
	}
	return &response, nil
}

func (c *testServiceNATSClient) NormalEmptyTest(opts ...go_nats.CallOption) (*Test, error) {
	var response Test

	if err := c.handleWithRetry(nil, "service.TestService.NormalEmptyTest", &response, opts...); err != nil {
		return nil, err
	}
	return &response, nil
}

func (c *testServiceNATSClient) NormalTestEmpty(req *Test, opts ...go_nats.CallOption) error {
	if err := c.handleWithRetry(req, "service.TestService.NormalTestEmpty", nil, opts...); err != nil {
		return err
	}
	return nil
}

func (c *testServiceNATSClient) NormalEmptyEmpty(opts ...go_nats.CallOption) error {
	if err := c.handleWithRetry(nil, "service.TestService.NormalEmptyEmpty", nil, opts...); err != nil {
		return err
	}
	return nil
}

func (c *testServiceNATSClient) ErrServiceError(req *Test, opts ...go_nats.CallOption) (*Test, error) {
	var response Test

	if err := c.handleWithRetry(req, "service.TestService.ErrServiceError", &response, opts...); err != nil {
		return nil, err
	}
	return &response, nil
}

func (c *testServiceNATSClient) ErrServerError(req *Test, opts ...go_nats.CallOption) (*Test, error) {
	var response Test

	if err := c.handleWithRetry(req, "service.TestService.ErrServerError", &response, opts...); err != nil {
		return nil, err
	}
	return &response, nil
}

func (c *testServiceNATSClient) ErrServiceErrorBroadcast(req *Test, opts ...go_nats.CallOption) ([]*Test, []go_nats.ServiceError, error) {
	options := impl.ProcessCallOptions(opts...)
	timeout := options.GetTimeoutOr(c.timeout)

	var data []byte
	if req != nil {
		var err error
		if data, err = proto.Marshal(req); err != nil {
			return nil, nil, go_nats.ErrMarshallingFailed
		}
	}
	objs, serviceErrs, err := request(c.nc, timeout, options.DisableFinisher, "service.TestService.ErrServiceErrorBroadcast", data, func(data []byte, rtt time.Duration) (*Test, error) {
		var obj Test
		if err := proto.Unmarshal(data, &obj); err != nil {
			return nil, err
		}
		return &obj, nil
	})
	return objs, serviceErrs, err
}

func (c *testServiceNATSClient) ErrServerErrorBroadcast(req *Test, opts ...go_nats.CallOption) ([]*Test, []go_nats.ServiceError, error) {
	options := impl.ProcessCallOptions(opts...)
	timeout := options.GetTimeoutOr(c.timeout)

	var data []byte
	if req != nil {
		var err error
		if data, err = proto.Marshal(req); err != nil {
			return nil, nil, go_nats.ErrMarshallingFailed
		}
	}
	objs, serviceErrs, err := request(c.nc, timeout, options.DisableFinisher, "service.TestService.ErrServerErrorBroadcast", data, func(data []byte, rtt time.Duration) (*Test, error) {
		var obj Test
		if err := proto.Unmarshal(data, &obj); err != nil {
			return nil, err
		}
		return &obj, nil
	})
	return objs, serviceErrs, err
}

func (c *testServiceNATSClient) NormalBroadcastTestTest(req *Test, opts ...go_nats.CallOption) ([]*Test, []go_nats.ServiceError, error) {
	options := impl.ProcessCallOptions(opts...)
	timeout := options.GetTimeoutOr(c.timeout)

	var data []byte
	if req != nil {
		var err error
		if data, err = proto.Marshal(req); err != nil {
			return nil, nil, go_nats.ErrMarshallingFailed
		}
	}
	objs, serviceErrs, err := request(c.nc, timeout, options.DisableFinisher, "service.TestService.NormalBroadcastTestTest", data, func(data []byte, rtt time.Duration) (*Test, error) {
		var obj Test
		if err := proto.Unmarshal(data, &obj); err != nil {
			return nil, err
		}
		return &obj, nil
	})
	return objs, serviceErrs, err
}

func (c *testServiceNATSClient) NormalBroadcastEmptyTest(opts ...go_nats.CallOption) ([]*Test, []go_nats.ServiceError, error) {
	options := impl.ProcessCallOptions(opts...)
	timeout := options.GetTimeoutOr(c.timeout)

	objs, serviceErrs, err := request(c.nc, timeout, options.DisableFinisher, "service.TestService.NormalBroadcastEmptyTest", nil, func(data []byte, rtt time.Duration) (*Test, error) {
		var obj Test
		if err := proto.Unmarshal(data, &obj); err != nil {
			return nil, err
		}
		return &obj, nil
	})
	return objs, serviceErrs, err
}

func (c *testServiceNATSClient) NormalBroadcastTestEmpty(req *Test, opts ...go_nats.CallOption) ([]go_nats.ServiceError, error) {
	options := impl.ProcessCallOptions(opts...)
	timeout := options.GetTimeoutOr(c.timeout)

	var data []byte
	if req != nil {
		var err error
		if data, err = proto.Marshal(req); err != nil {
			return nil, go_nats.ErrMarshallingFailed
		}
	}
	_, serviceErrs, err := request[struct{}](c.nc, timeout, options.DisableFinisher, "service.TestService.NormalBroadcastTestEmpty", data, nil)
	return serviceErrs, err
}

func (c *testServiceNATSClient) NormalBroadcastEmptyEmpty(opts ...go_nats.CallOption) ([]go_nats.ServiceError, error) {
	options := impl.ProcessCallOptions(opts...)
	timeout := options.GetTimeoutOr(c.timeout)

	_, serviceErrs, err := request[struct{}](c.nc, timeout, options.DisableFinisher, "service.TestService.NormalBroadcastEmptyEmpty", nil, nil)
	return serviceErrs, err
}

func (c *testServiceNATSClient) LeaderOnlyTestTest(req *Test, opts ...go_nats.CallOption) (*Test, error) {
	var response Test

	if err := c.handleWithRetry(req, "service.TestService.LeaderOnlyTestTest", &response, opts...); err != nil {
		return nil, err
	}
	return &response, nil
}

func (c *testServiceNATSClient) LeaderOnlyEmptyTest(opts ...go_nats.CallOption) (*Test, error) {
	var response Test

	if err := c.handleWithRetry(nil, "service.TestService.LeaderOnlyEmptyTest", &response, opts...); err != nil {
		return nil, err
	}
	return &response, nil
}

func (c *testServiceNATSClient) LeaderOnlyTestEmpty(req *Test, opts ...go_nats.CallOption) error {
	if err := c.handleWithRetry(req, "service.TestService.LeaderOnlyTestEmpty", nil, opts...); err != nil {
		return err
	}
	return nil
}

func (c *testServiceNATSClient) LeaderOnlyEmptyEmpty(opts ...go_nats.CallOption) error {
	if err := c.handleWithRetry(nil, "service.TestService.LeaderOnlyEmptyEmpty", nil, opts...); err != nil {
		return err
	}
	return nil
}

func (c *testServiceNATSClient) LeaderOnlyBroadcastTestTest(req *Test, opts ...go_nats.CallOption) ([]*Test, []go_nats.ServiceError, error) {
	options := impl.ProcessCallOptions(opts...)
	timeout := options.GetTimeoutOr(c.timeout)

	var data []byte
	if req != nil {
		var err error
		if data, err = proto.Marshal(req); err != nil {
			return nil, nil, go_nats.ErrMarshallingFailed
		}
	}
	objs, serviceErrs, err := request(c.nc, timeout, options.DisableFinisher, "service.TestService.LeaderOnlyBroadcastTestTest", data, func(data []byte, rtt time.Duration) (*Test, error) {
		var obj Test
		if err := proto.Unmarshal(data, &obj); err != nil {
			return nil, err
		}
		return &obj, nil
	})
	return objs, serviceErrs, err
}

func (c *testServiceNATSClient) LeaderOnlyBroadcastEmptyTest(opts ...go_nats.CallOption) ([]*Test, []go_nats.ServiceError, error) {
	options := impl.ProcessCallOptions(opts...)
	timeout := options.GetTimeoutOr(c.timeout)

	objs, serviceErrs, err := request(c.nc, timeout, options.DisableFinisher, "service.TestService.LeaderOnlyBroadcastEmptyTest", nil, func(data []byte, rtt time.Duration) (*Test, error) {
		var obj Test
		if err := proto.Unmarshal(data, &obj); err != nil {
			return nil, err
		}
		return &obj, nil
	})
	return objs, serviceErrs, err
}

func (c *testServiceNATSClient) LeaderOnlyBroadcastTestEmpty(req *Test, opts ...go_nats.CallOption) ([]go_nats.ServiceError, error) {
	options := impl.ProcessCallOptions(opts...)
	timeout := options.GetTimeoutOr(c.timeout)

	var data []byte
	if req != nil {
		var err error
		if data, err = proto.Marshal(req); err != nil {
			return nil, go_nats.ErrMarshallingFailed
		}
	}
	_, serviceErrs, err := request[struct{}](c.nc, timeout, options.DisableFinisher, "service.TestService.LeaderOnlyBroadcastTestEmpty", data, nil)
	return serviceErrs, err
}

func (c *testServiceNATSClient) LeaderOnlyBroadcastEmptyEmpty(opts ...go_nats.CallOption) ([]go_nats.ServiceError, error) {
	options := impl.ProcessCallOptions(opts...)
	timeout := options.GetTimeoutOr(c.timeout)

	_, serviceErrs, err := request[struct{}](c.nc, timeout, options.DisableFinisher, "service.TestService.LeaderOnlyBroadcastEmptyEmpty", nil, nil)
	return serviceErrs, err
}

func (c *testServiceNATSClient) FollowerOnlyTestTest(req *Test, opts ...go_nats.CallOption) (*Test, error) {
	var response Test

	if err := c.handleWithRetry(req, "service.TestService.FollowerOnlyTestTest", &response, opts...); err != nil {
		return nil, err
	}
	return &response, nil
}

func (c *testServiceNATSClient) FollowerOnlyEmptyTest(opts ...go_nats.CallOption) (*Test, error) {
	var response Test

	if err := c.handleWithRetry(nil, "service.TestService.FollowerOnlyEmptyTest", &response, opts...); err != nil {
		return nil, err
	}
	return &response, nil
}

func (c *testServiceNATSClient) FollowerOnlyTestEmpty(req *Test, opts ...go_nats.CallOption) error {
	if err := c.handleWithRetry(req, "service.TestService.FollowerOnlyTestEmpty", nil, opts...); err != nil {
		return err
	}
	return nil
}

func (c *testServiceNATSClient) FollowerOnlyEmptyEmpty(opts ...go_nats.CallOption) error {
	if err := c.handleWithRetry(nil, "service.TestService.FollowerOnlyEmptyEmpty", nil, opts...); err != nil {
		return err
	}
	return nil
}

func (c *testServiceNATSClient) FollowerOnlyBroadcastTestTest(req *Test, opts ...go_nats.CallOption) ([]*Test, []go_nats.ServiceError, error) {
	options := impl.ProcessCallOptions(opts...)
	timeout := options.GetTimeoutOr(c.timeout)

	var data []byte
	if req != nil {
		var err error
		if data, err = proto.Marshal(req); err != nil {
			return nil, nil, go_nats.ErrMarshallingFailed
		}
	}
	objs, serviceErrs, err := request(c.nc, timeout, options.DisableFinisher, "service.TestService.FollowerOnlyBroadcastTestTest", data, func(data []byte, rtt time.Duration) (*Test, error) {
		var obj Test
		if err := proto.Unmarshal(data, &obj); err != nil {
			return nil, err
		}
		return &obj, nil
	})
	return objs, serviceErrs, err
}

func (c *testServiceNATSClient) FollowerOnlyBroadcastEmptyTest(opts ...go_nats.CallOption) ([]*Test, []go_nats.ServiceError, error) {
	options := impl.ProcessCallOptions(opts...)
	timeout := options.GetTimeoutOr(c.timeout)

	objs, serviceErrs, err := request(c.nc, timeout, options.DisableFinisher, "service.TestService.FollowerOnlyBroadcastEmptyTest", nil, func(data []byte, rtt time.Duration) (*Test, error) {
		var obj Test
		if err := proto.Unmarshal(data, &obj); err != nil {
			return nil, err
		}
		return &obj, nil
	})
	return objs, serviceErrs, err
}

func (c *testServiceNATSClient) FollowerOnlyBroadcastTestEmpty(req *Test, opts ...go_nats.CallOption) ([]go_nats.ServiceError, error) {
	options := impl.ProcessCallOptions(opts...)
	timeout := options.GetTimeoutOr(c.timeout)

	var data []byte
	if req != nil {
		var err error
		if data, err = proto.Marshal(req); err != nil {
			return nil, go_nats.ErrMarshallingFailed
		}
	}
	_, serviceErrs, err := request[struct{}](c.nc, timeout, options.DisableFinisher, "service.TestService.FollowerOnlyBroadcastTestEmpty", data, nil)
	return serviceErrs, err
}

func (c *testServiceNATSClient) FollowerOnlyBroadcastEmptyEmpty(opts ...go_nats.CallOption) ([]go_nats.ServiceError, error) {
	options := impl.ProcessCallOptions(opts...)
	timeout := options.GetTimeoutOr(c.timeout)

	_, serviceErrs, err := request[struct{}](c.nc, timeout, options.DisableFinisher, "service.TestService.FollowerOnlyBroadcastEmptyEmpty", nil, nil)
	return serviceErrs, err
}

//endregion

// region Server
type TestServiceNATSServer interface {
	// Normal tests
	NormalTestTest(req *Test) (*Test, error)
	NormalEmptyTest() (*Test, error)
	NormalTestEmpty(req *Test) error
	NormalEmptyEmpty() error
	// Methods that will expect an error in the test implementation
	ErrServiceError(req *Test) (*Test, error)
	ErrServerError(req *Test) (*Test, error)
	ErrServiceErrorBroadcast(req *Test) (*Test, error)
	ErrServerErrorBroadcast(req *Test) (*Test, error)
	// Normal tests with broadcast option
	NormalBroadcastTestTest(req *Test) (*Test, error)
	NormalBroadcastEmptyTest() (*Test, error)
	NormalBroadcastTestEmpty(req *Test) error
	NormalBroadcastEmptyEmpty() error
	TestServiceNATSLeaderServer
	TestServiceNATSFollowerServer
}

type TestServiceNATSLeaderServer interface {
	// Leader option tests
	LeaderOnlyTestTest(req *Test) (*Test, error)
	LeaderOnlyEmptyTest() (*Test, error)
	LeaderOnlyTestEmpty(req *Test) error
	LeaderOnlyEmptyEmpty() error
	// Leader with broadcast option tests
	LeaderOnlyBroadcastTestTest(req *Test) (*Test, error)
	LeaderOnlyBroadcastEmptyTest() (*Test, error)
	LeaderOnlyBroadcastTestEmpty(req *Test) error
	LeaderOnlyBroadcastEmptyEmpty() error
}

type TestServiceNATSFollowerServer interface {
	// Follower option tests
	FollowerOnlyTestTest(req *Test) (*Test, error)
	FollowerOnlyEmptyTest() (*Test, error)
	FollowerOnlyTestEmpty(req *Test) error
	FollowerOnlyEmptyEmpty() error
	// Follower with broadcast option tests
	FollowerOnlyBroadcastTestTest(req *Test) (*Test, error)
	FollowerOnlyBroadcastEmptyTest() (*Test, error)
	FollowerOnlyBroadcastTestEmpty(req *Test) error
	FollowerOnlyBroadcastEmptyEmpty() error
}

type TestServiceId interface {
	SetTestServiceId(string)
}

func NewTestServiceNATSServer(nc *nats_go.Conn, server TestServiceNATSServer, opts ...go_nats.ServerOption) micro.Service {
	service, options, err := impl.NewService("TestService", nc, server, opts...)
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}
	if setId, ok := server.(TestServiceId); ok {
		setId.SetTestServiceId(service.Info().ID)
	}
	_newTestServiceServer(service, server, options)

	if !options.WithoutLeaderFunctions {
		_newTestServiceLeaderServer(service, server, options)
	}
	if !options.WithoutFollowerFunctions {
		_newTestServiceFollowerServer(service, server, options)
	}
	return service
}
func _newTestServiceServer(service micro.Service, server TestServiceNATSServer, opts *impl.ServerOpts) {
	var err error
	_ = err

	// Register the service's methods
	NormalTestTestHandler := micro.HandlerFunc(func(request micro.Request) {
		var req Test
		if err := proto.Unmarshal(request.Data(), &req); err != nil {
			request.Error("560", "Failed to unmarshal proto message", []byte(err.Error()))
			return
		}

		response, err := server.NormalTestTest(&req)
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		data, err := proto.Marshal(response)
		if err != nil {
			request.Error("560", "Failed to marshal proto message", []byte(err.Error()))
			return
		}
		request.Respond(data)
	})
	err = service.AddEndpoint("NormalTestTest", NormalTestTestHandler, opts.Subject("service.TestService.NormalTestTest", ""))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}
	err = service.AddEndpoint("NormalTestTest-Direct", NormalTestTestHandler, opts.Subject("service.TestService.NormalTestTest", service.Info().ID))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}

	NormalEmptyTestHandler := micro.HandlerFunc(func(request micro.Request) {
		response, err := server.NormalEmptyTest()
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		data, err := proto.Marshal(response)
		if err != nil {
			request.Error("560", "Failed to marshal proto message", []byte(err.Error()))
			return
		}
		request.Respond(data)
	})
	err = service.AddEndpoint("NormalEmptyTest", NormalEmptyTestHandler, opts.Subject("service.TestService.NormalEmptyTest", ""))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}
	err = service.AddEndpoint("NormalEmptyTest-Direct", NormalEmptyTestHandler, opts.Subject("service.TestService.NormalEmptyTest", service.Info().ID))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}

	NormalTestEmptyHandler := micro.HandlerFunc(func(request micro.Request) {
		var req Test
		if err := proto.Unmarshal(request.Data(), &req); err != nil {
			request.Error("560", "Failed to unmarshal proto message", []byte(err.Error()))
			return
		}

		err := server.NormalTestEmpty(&req)
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		request.Respond(nil)
	})
	err = service.AddEndpoint("NormalTestEmpty", NormalTestEmptyHandler, opts.Subject("service.TestService.NormalTestEmpty", ""))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}
	err = service.AddEndpoint("NormalTestEmpty-Direct", NormalTestEmptyHandler, opts.Subject("service.TestService.NormalTestEmpty", service.Info().ID))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}

	NormalEmptyEmptyHandler := micro.HandlerFunc(func(request micro.Request) {
		err := server.NormalEmptyEmpty()
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		request.Respond(nil)
	})
	err = service.AddEndpoint("NormalEmptyEmpty", NormalEmptyEmptyHandler, opts.Subject("service.TestService.NormalEmptyEmpty", ""))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}
	err = service.AddEndpoint("NormalEmptyEmpty-Direct", NormalEmptyEmptyHandler, opts.Subject("service.TestService.NormalEmptyEmpty", service.Info().ID))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}

	ErrServiceErrorHandler := micro.HandlerFunc(func(request micro.Request) {
		var req Test
		if err := proto.Unmarshal(request.Data(), &req); err != nil {
			request.Error("560", "Failed to unmarshal proto message", []byte(err.Error()))
			return
		}

		response, err := server.ErrServiceError(&req)
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		data, err := proto.Marshal(response)
		if err != nil {
			request.Error("560", "Failed to marshal proto message", []byte(err.Error()))
			return
		}
		request.Respond(data)
	})
	err = service.AddEndpoint("ErrServiceError", ErrServiceErrorHandler, opts.Subject("service.TestService.ErrServiceError", ""))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}
	err = service.AddEndpoint("ErrServiceError-Direct", ErrServiceErrorHandler, opts.Subject("service.TestService.ErrServiceError", service.Info().ID))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}

	ErrServerErrorHandler := micro.HandlerFunc(func(request micro.Request) {
		var req Test
		if err := proto.Unmarshal(request.Data(), &req); err != nil {
			request.Error("560", "Failed to unmarshal proto message", []byte(err.Error()))
			return
		}

		response, err := server.ErrServerError(&req)
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		data, err := proto.Marshal(response)
		if err != nil {
			request.Error("560", "Failed to marshal proto message", []byte(err.Error()))
			return
		}
		request.Respond(data)
	})
	err = service.AddEndpoint("ErrServerError", ErrServerErrorHandler, opts.Subject("service.TestService.ErrServerError", ""))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}
	err = service.AddEndpoint("ErrServerError-Direct", ErrServerErrorHandler, opts.Subject("service.TestService.ErrServerError", service.Info().ID))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}

	ErrServiceErrorBroadcastHandler := micro.HandlerFunc(func(request micro.Request) {
		var req Test
		if err := proto.Unmarshal(request.Data(), &req); err != nil {
			request.Error("560", "Failed to unmarshal proto message", []byte(err.Error()))
			return
		}

		response, err := server.ErrServiceErrorBroadcast(&req)
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		data, err := proto.Marshal(response)
		if err != nil {
			request.Error("560", "Failed to marshal proto message", []byte(err.Error()))
			return
		}
		request.Respond(data)
	})
	err = service.AddEndpoint("ErrServiceErrorBroadcast-Broadcast", ErrServiceErrorBroadcastHandler, micro.WithEndpointQueueGroup(nuid.Next()), opts.Subject("service.TestService.ErrServiceErrorBroadcast", ""))

	ErrServerErrorBroadcastHandler := micro.HandlerFunc(func(request micro.Request) {
		var req Test
		if err := proto.Unmarshal(request.Data(), &req); err != nil {
			request.Error("560", "Failed to unmarshal proto message", []byte(err.Error()))
			return
		}

		response, err := server.ErrServerErrorBroadcast(&req)
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		data, err := proto.Marshal(response)
		if err != nil {
			request.Error("560", "Failed to marshal proto message", []byte(err.Error()))
			return
		}
		request.Respond(data)
	})
	err = service.AddEndpoint("ErrServerErrorBroadcast-Broadcast", ErrServerErrorBroadcastHandler, micro.WithEndpointQueueGroup(nuid.Next()), opts.Subject("service.TestService.ErrServerErrorBroadcast", ""))

	NormalBroadcastTestTestHandler := micro.HandlerFunc(func(request micro.Request) {
		var req Test
		if err := proto.Unmarshal(request.Data(), &req); err != nil {
			request.Error("560", "Failed to unmarshal proto message", []byte(err.Error()))
			return
		}

		response, err := server.NormalBroadcastTestTest(&req)
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		data, err := proto.Marshal(response)
		if err != nil {
			request.Error("560", "Failed to marshal proto message", []byte(err.Error()))
			return
		}
		request.Respond(data)
	})
	err = service.AddEndpoint("NormalBroadcastTestTest-Broadcast", NormalBroadcastTestTestHandler, micro.WithEndpointQueueGroup(nuid.Next()), opts.Subject("service.TestService.NormalBroadcastTestTest", ""))

	NormalBroadcastEmptyTestHandler := micro.HandlerFunc(func(request micro.Request) {
		response, err := server.NormalBroadcastEmptyTest()
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		data, err := proto.Marshal(response)
		if err != nil {
			request.Error("560", "Failed to marshal proto message", []byte(err.Error()))
			return
		}
		request.Respond(data)
	})
	err = service.AddEndpoint("NormalBroadcastEmptyTest-Broadcast", NormalBroadcastEmptyTestHandler, micro.WithEndpointQueueGroup(nuid.Next()), opts.Subject("service.TestService.NormalBroadcastEmptyTest", ""))

	NormalBroadcastTestEmptyHandler := micro.HandlerFunc(func(request micro.Request) {
		var req Test
		if err := proto.Unmarshal(request.Data(), &req); err != nil {
			request.Error("560", "Failed to unmarshal proto message", []byte(err.Error()))
			return
		}

		err := server.NormalBroadcastTestEmpty(&req)
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		request.Respond(nil)
	})
	err = service.AddEndpoint("NormalBroadcastTestEmpty-Broadcast", NormalBroadcastTestEmptyHandler, micro.WithEndpointQueueGroup(nuid.Next()), opts.Subject("service.TestService.NormalBroadcastTestEmpty", ""))

	NormalBroadcastEmptyEmptyHandler := micro.HandlerFunc(func(request micro.Request) {
		err := server.NormalBroadcastEmptyEmpty()
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		request.Respond(nil)
	})
	err = service.AddEndpoint("NormalBroadcastEmptyEmpty-Broadcast", NormalBroadcastEmptyEmptyHandler, micro.WithEndpointQueueGroup(nuid.Next()), opts.Subject("service.TestService.NormalBroadcastEmptyEmpty", ""))

}

func NewTestServiceNATSLeaderServer(nc *nats_go.Conn, server TestServiceNATSLeaderServer, opts ...go_nats.ServerOption) micro.Service {
	service, options, err := impl.NewService("TestService", nc, server, opts...)
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}
	if setId, ok := server.(TestServiceId); ok {
		setId.SetTestServiceId(service.Info().ID)
	}
	_newTestServiceLeaderServer(service, server, options)
	return service
}

func _newTestServiceLeaderServer(service micro.Service, server TestServiceNATSLeaderServer, opts *impl.ServerOpts) {
	var err error
	_ = err
	LeaderOnlyTestTestHandler := micro.HandlerFunc(func(request micro.Request) {
		var req Test
		if err := proto.Unmarshal(request.Data(), &req); err != nil {
			request.Error("560", "Failed to unmarshal proto message", []byte(err.Error()))
			return
		}

		response, err := server.LeaderOnlyTestTest(&req)
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		data, err := proto.Marshal(response)
		if err != nil {
			request.Error("560", "Failed to marshal proto message", []byte(err.Error()))
			return
		}
		request.Respond(data)
	})
	err = service.AddEndpoint("LeaderOnlyTestTest", LeaderOnlyTestTestHandler, opts.Subject("service.TestService.LeaderOnlyTestTest", ""))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}
	err = service.AddEndpoint("LeaderOnlyTestTest-Direct", LeaderOnlyTestTestHandler, opts.Subject("service.TestService.LeaderOnlyTestTest", service.Info().ID))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}

	LeaderOnlyEmptyTestHandler := micro.HandlerFunc(func(request micro.Request) {
		response, err := server.LeaderOnlyEmptyTest()
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		data, err := proto.Marshal(response)
		if err != nil {
			request.Error("560", "Failed to marshal proto message", []byte(err.Error()))
			return
		}
		request.Respond(data)
	})
	err = service.AddEndpoint("LeaderOnlyEmptyTest", LeaderOnlyEmptyTestHandler, opts.Subject("service.TestService.LeaderOnlyEmptyTest", ""))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}
	err = service.AddEndpoint("LeaderOnlyEmptyTest-Direct", LeaderOnlyEmptyTestHandler, opts.Subject("service.TestService.LeaderOnlyEmptyTest", service.Info().ID))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}

	LeaderOnlyTestEmptyHandler := micro.HandlerFunc(func(request micro.Request) {
		var req Test
		if err := proto.Unmarshal(request.Data(), &req); err != nil {
			request.Error("560", "Failed to unmarshal proto message", []byte(err.Error()))
			return
		}

		err := server.LeaderOnlyTestEmpty(&req)
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		request.Respond(nil)
	})
	err = service.AddEndpoint("LeaderOnlyTestEmpty", LeaderOnlyTestEmptyHandler, opts.Subject("service.TestService.LeaderOnlyTestEmpty", ""))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}
	err = service.AddEndpoint("LeaderOnlyTestEmpty-Direct", LeaderOnlyTestEmptyHandler, opts.Subject("service.TestService.LeaderOnlyTestEmpty", service.Info().ID))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}

	LeaderOnlyEmptyEmptyHandler := micro.HandlerFunc(func(request micro.Request) {
		err := server.LeaderOnlyEmptyEmpty()
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		request.Respond(nil)
	})
	err = service.AddEndpoint("LeaderOnlyEmptyEmpty", LeaderOnlyEmptyEmptyHandler, opts.Subject("service.TestService.LeaderOnlyEmptyEmpty", ""))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}
	err = service.AddEndpoint("LeaderOnlyEmptyEmpty-Direct", LeaderOnlyEmptyEmptyHandler, opts.Subject("service.TestService.LeaderOnlyEmptyEmpty", service.Info().ID))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}

	LeaderOnlyBroadcastTestTestHandler := micro.HandlerFunc(func(request micro.Request) {
		var req Test
		if err := proto.Unmarshal(request.Data(), &req); err != nil {
			request.Error("560", "Failed to unmarshal proto message", []byte(err.Error()))
			return
		}

		response, err := server.LeaderOnlyBroadcastTestTest(&req)
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		data, err := proto.Marshal(response)
		if err != nil {
			request.Error("560", "Failed to marshal proto message", []byte(err.Error()))
			return
		}
		request.Respond(data)
	})
	err = service.AddEndpoint("LeaderOnlyBroadcastTestTest-Broadcast", LeaderOnlyBroadcastTestTestHandler, micro.WithEndpointQueueGroup(nuid.Next()), opts.Subject("service.TestService.LeaderOnlyBroadcastTestTest", ""))

	LeaderOnlyBroadcastEmptyTestHandler := micro.HandlerFunc(func(request micro.Request) {
		response, err := server.LeaderOnlyBroadcastEmptyTest()
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		data, err := proto.Marshal(response)
		if err != nil {
			request.Error("560", "Failed to marshal proto message", []byte(err.Error()))
			return
		}
		request.Respond(data)
	})
	err = service.AddEndpoint("LeaderOnlyBroadcastEmptyTest-Broadcast", LeaderOnlyBroadcastEmptyTestHandler, micro.WithEndpointQueueGroup(nuid.Next()), opts.Subject("service.TestService.LeaderOnlyBroadcastEmptyTest", ""))

	LeaderOnlyBroadcastTestEmptyHandler := micro.HandlerFunc(func(request micro.Request) {
		var req Test
		if err := proto.Unmarshal(request.Data(), &req); err != nil {
			request.Error("560", "Failed to unmarshal proto message", []byte(err.Error()))
			return
		}

		err := server.LeaderOnlyBroadcastTestEmpty(&req)
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		request.Respond(nil)
	})
	err = service.AddEndpoint("LeaderOnlyBroadcastTestEmpty-Broadcast", LeaderOnlyBroadcastTestEmptyHandler, micro.WithEndpointQueueGroup(nuid.Next()), opts.Subject("service.TestService.LeaderOnlyBroadcastTestEmpty", ""))

	LeaderOnlyBroadcastEmptyEmptyHandler := micro.HandlerFunc(func(request micro.Request) {
		err := server.LeaderOnlyBroadcastEmptyEmpty()
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		request.Respond(nil)
	})
	err = service.AddEndpoint("LeaderOnlyBroadcastEmptyEmpty-Broadcast", LeaderOnlyBroadcastEmptyEmptyHandler, micro.WithEndpointQueueGroup(nuid.Next()), opts.Subject("service.TestService.LeaderOnlyBroadcastEmptyEmpty", ""))

}

func NewTestServiceNATSFollowerServer(nc *nats_go.Conn, server TestServiceNATSFollowerServer, opts ...go_nats.ServerOption) micro.Service {
	service, options, err := impl.NewService("TestService", nc, server, opts...)
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}
	if setId, ok := server.(TestServiceId); ok {
		setId.SetTestServiceId(service.Info().ID)
	}
	_newTestServiceFollowerServer(service, server, options)
	return service
}

func _newTestServiceFollowerServer(service micro.Service, server TestServiceNATSFollowerServer, opts *impl.ServerOpts) {
	var err error
	_ = err
	FollowerOnlyTestTestHandler := micro.HandlerFunc(func(request micro.Request) {
		var req Test
		if err := proto.Unmarshal(request.Data(), &req); err != nil {
			request.Error("560", "Failed to unmarshal proto message", []byte(err.Error()))
			return
		}

		response, err := server.FollowerOnlyTestTest(&req)
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		data, err := proto.Marshal(response)
		if err != nil {
			request.Error("560", "Failed to marshal proto message", []byte(err.Error()))
			return
		}
		request.Respond(data)
	})
	err = service.AddEndpoint("FollowerOnlyTestTest", FollowerOnlyTestTestHandler, opts.Subject("service.TestService.FollowerOnlyTestTest", ""))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}
	err = service.AddEndpoint("FollowerOnlyTestTest-Direct", FollowerOnlyTestTestHandler, opts.Subject("service.TestService.FollowerOnlyTestTest", service.Info().ID))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}

	FollowerOnlyEmptyTestHandler := micro.HandlerFunc(func(request micro.Request) {
		response, err := server.FollowerOnlyEmptyTest()
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		data, err := proto.Marshal(response)
		if err != nil {
			request.Error("560", "Failed to marshal proto message", []byte(err.Error()))
			return
		}
		request.Respond(data)
	})
	err = service.AddEndpoint("FollowerOnlyEmptyTest", FollowerOnlyEmptyTestHandler, opts.Subject("service.TestService.FollowerOnlyEmptyTest", ""))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}
	err = service.AddEndpoint("FollowerOnlyEmptyTest-Direct", FollowerOnlyEmptyTestHandler, opts.Subject("service.TestService.FollowerOnlyEmptyTest", service.Info().ID))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}

	FollowerOnlyTestEmptyHandler := micro.HandlerFunc(func(request micro.Request) {
		var req Test
		if err := proto.Unmarshal(request.Data(), &req); err != nil {
			request.Error("560", "Failed to unmarshal proto message", []byte(err.Error()))
			return
		}

		err := server.FollowerOnlyTestEmpty(&req)
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		request.Respond(nil)
	})
	err = service.AddEndpoint("FollowerOnlyTestEmpty", FollowerOnlyTestEmptyHandler, opts.Subject("service.TestService.FollowerOnlyTestEmpty", ""))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}
	err = service.AddEndpoint("FollowerOnlyTestEmpty-Direct", FollowerOnlyTestEmptyHandler, opts.Subject("service.TestService.FollowerOnlyTestEmpty", service.Info().ID))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}

	FollowerOnlyEmptyEmptyHandler := micro.HandlerFunc(func(request micro.Request) {
		err := server.FollowerOnlyEmptyEmpty()
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		request.Respond(nil)
	})
	err = service.AddEndpoint("FollowerOnlyEmptyEmpty", FollowerOnlyEmptyEmptyHandler, opts.Subject("service.TestService.FollowerOnlyEmptyEmpty", ""))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}
	err = service.AddEndpoint("FollowerOnlyEmptyEmpty-Direct", FollowerOnlyEmptyEmptyHandler, opts.Subject("service.TestService.FollowerOnlyEmptyEmpty", service.Info().ID))
	if err != nil {
		panic(err) // TODO: Update this to proper error handling
	}

	FollowerOnlyBroadcastTestTestHandler := micro.HandlerFunc(func(request micro.Request) {
		var req Test
		if err := proto.Unmarshal(request.Data(), &req); err != nil {
			request.Error("560", "Failed to unmarshal proto message", []byte(err.Error()))
			return
		}

		response, err := server.FollowerOnlyBroadcastTestTest(&req)
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		data, err := proto.Marshal(response)
		if err != nil {
			request.Error("560", "Failed to marshal proto message", []byte(err.Error()))
			return
		}
		request.Respond(data)
	})
	err = service.AddEndpoint("FollowerOnlyBroadcastTestTest-Broadcast", FollowerOnlyBroadcastTestTestHandler, micro.WithEndpointQueueGroup(nuid.Next()), opts.Subject("service.TestService.FollowerOnlyBroadcastTestTest", ""))

	FollowerOnlyBroadcastEmptyTestHandler := micro.HandlerFunc(func(request micro.Request) {
		response, err := server.FollowerOnlyBroadcastEmptyTest()
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		data, err := proto.Marshal(response)
		if err != nil {
			request.Error("560", "Failed to marshal proto message", []byte(err.Error()))
			return
		}
		request.Respond(data)
	})
	err = service.AddEndpoint("FollowerOnlyBroadcastEmptyTest-Broadcast", FollowerOnlyBroadcastEmptyTestHandler, micro.WithEndpointQueueGroup(nuid.Next()), opts.Subject("service.TestService.FollowerOnlyBroadcastEmptyTest", ""))

	FollowerOnlyBroadcastTestEmptyHandler := micro.HandlerFunc(func(request micro.Request) {
		var req Test
		if err := proto.Unmarshal(request.Data(), &req); err != nil {
			request.Error("560", "Failed to unmarshal proto message", []byte(err.Error()))
			return
		}

		err := server.FollowerOnlyBroadcastTestEmpty(&req)
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		request.Respond(nil)
	})
	err = service.AddEndpoint("FollowerOnlyBroadcastTestEmpty-Broadcast", FollowerOnlyBroadcastTestEmptyHandler, micro.WithEndpointQueueGroup(nuid.Next()), opts.Subject("service.TestService.FollowerOnlyBroadcastTestEmpty", ""))

	FollowerOnlyBroadcastEmptyEmptyHandler := micro.HandlerFunc(func(request micro.Request) {
		err := server.FollowerOnlyBroadcastEmptyEmpty()
		if err != nil {
			if go_nats.IsServiceError(err) {
				slog.Warn("Server implementations should not return ServiceError, use go_nats.NewServerError instead", "error", err)
			}
			var serverErr go_nats.ServerError
			if errors.As(err, &serverErr) {
				request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())
			} else {
				request.Error("500", "Internal server error", []byte(err.Error()))
			}
			return
		}

		request.Respond(nil)
	})
	err = service.AddEndpoint("FollowerOnlyBroadcastEmptyEmpty-Broadcast", FollowerOnlyBroadcastEmptyEmptyHandler, micro.WithEndpointQueueGroup(nuid.Next()), opts.Subject("service.TestService.FollowerOnlyBroadcastEmptyEmpty", ""))

}

//endregion
