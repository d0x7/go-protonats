package main

import (
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"strconv"
	"strings"
)

const (
	natsPkg   = protogen.GoImportPath("github.com/nats-io/nats.go")
	microPkg  = protogen.GoImportPath("github.com/nats-io/nats.go/micro")
	timePkg   = protogen.GoImportPath("time")
	slogPkg   = protogen.GoImportPath("log/slog")
	protoPkg  = protogen.GoImportPath("google.golang.org/protobuf/proto")
	goNatsPkg = protogen.GoImportPath("xiam.li/go-nats")
)

var (
	natsConn       = natsPkg.Ident("Conn")
	microConfig    = microPkg.Ident("Config")
	microRequest   = microPkg.Ident("Request")
	timeDuration   = timePkg.Ident("Duration")
	debugLogger    = slogPkg.Ident("Debug")
	protoMessage   = protoPkg.Ident("Message")
	protoMarshal   = protoPkg.Ident("Marshal")
	protoUnmarshal = protoPkg.Ident("Unmarshal")

	emptyPb = "google/protobuf/empty.proto"

	// reservedKeywords is a map of reserved keywords that cannot be used as method names
	reservedKeywords = map[string]struct{}{
		"listinstances": {},
		"ping":          {},
		"stats":         {},
		"info":          {},
	}
)

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

func unexport(s string) string { return strings.ToLower(s[:1]) + s[1:] }

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Services) == 0 {
		return
	}
	filename := file.GeneratedFilenamePrefix + "_nats.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-nats. DO NOT EDIT.")
	g.P("// Versions:")
	g.P("// - protoc-gen-go-nats ", version)
	g.P("// - protoc        v", protocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	for _, service := range file.Services {
		generateService(g, service)
	}
}

func generateServer(g *protogen.GeneratedFile, service *protogen.Service) {
	srvName := service.GoName + "NATSServer"

	// Generate server interface
	g.P("//region Server")
	g.P("type ", srvName, " interface {")
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			// TODO: Skipping currently unsupported streaming methods for now
			g.P("// ", method.GoName, " is a streaming method and is currently not supported")
			continue
		}
		// Check if method.GoName is in reservedKeywords
		if _, ok := reservedKeywords[strings.ToLower(method.GoName)]; ok {
			g.P("// ", method.GoName, " is a reserved keyword and cannot be used as a method name")
			continue
		}
		var req, resp string
		if method.Input.Location.SourceFile != emptyPb {
			req = "req *" + g.QualifiedGoIdent(method.Input.GoIdent)
		}
		if method.Output.Location.SourceFile != emptyPb {
			resp = "*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", "
		}
		g.P(method.Comments.Leading, method.GoName, "(", req, ") (", resp, "error)")
	}
	g.P("}")
	g.P()

	// Generate server options
	g.P("type ServerOption func(config *", microConfig, ")")

	// Generate server option functions
	for _, typ := range []string{"StatsHandler", "DoneHandler", "ErrHandler"} {
		field := typ
		if typ == "ErrHandler" {
			field = "ErrorHandler"
		}
		g.P("func With", field, "(handler ", microPkg.Ident(typ), ") ServerOption {")
		g.P("return func(config *", microConfig, ") {")
		g.P("config.", field, " = handler")
		g.P("}")
		g.P("}")
		g.P()
	}

	// Generate NewServer function
	g.P("func New", srvName, "(nc *", natsConn, ", impl ", srvName, ", opts ...ServerOption) ", microPkg.Ident("Service"), " {")
	g.P("config := ", microConfig, "{")
	g.P("Name: ", strconv.Quote(service.GoName), ",")
	g.P("Version: ", strconv.Quote("1.0.0"), ",")
	g.P("}")
	g.P()

	g.P("// Check if the service implements any of the handler interfaces")
	g.P("// but do it before applying options, so these can still override the handlers")
	g.P("if statsHandler, isStatsHandler := impl.(", goNatsPkg.Ident("StatsHandler"), "); isStatsHandler {")
	g.P("config.StatsHandler = statsHandler.Stats")
	g.P(debugLogger, "(\"Service implements StatsHandler; using service's Stats method\")")
	g.P("}")
	g.P("if doneHandler, isDoneHandler := impl.(", goNatsPkg.Ident("DoneHandler"), "); isDoneHandler {")
	g.P("config.DoneHandler = doneHandler.Done")
	g.P(debugLogger, "(\"Service implements DoneHandler; using service's Done method\")")
	g.P("}")
	g.P("if errHandler, isErrHandler := impl.(", goNatsPkg.Ident("ErrHandler"), "); isErrHandler {")
	g.P("config.ErrorHandler = errHandler.Err")
	g.P(debugLogger, "(\"Service implements ErrHandler; using service's Err method\")")
	g.P("}")
	g.P()

	g.P("// Apply options")
	g.P("for _, opt := range opts {")
	g.P("opt(&config)")
	g.P("}")
	g.P()
	g.P("// Create the service")
	g.P("service, err := micro.AddService(nc, config)")
	g.P("if err != nil {")
	g.P("panic(err) // TODO: Update this to proper error handling")
	g.P("}")
	g.P()

	// Generate service endpoints
	g.P("// Register the service's methods")
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			// TODO: Skipping currently unsupported streaming methods for now
			continue
		}
		// Check if method.GoName is in reservedKeywords
		if _, ok := reservedKeywords[strings.ToLower(method.GoName)]; ok {
			continue
		}

		handler := method.GoName + "Handler"
		g.P(handler, " := ", microPkg.Ident("HandlerFunc"), "(func(request ", microRequest, ") {")

		var handlerReq string
		if method.Input.Location.SourceFile != emptyPb {
			handlerReq = "&req"
			g.P("var req ", method.Input.GoIdent)
			g.P("if err := ", protoUnmarshal, "(request.Data(), &req); err != nil {")
			g.P("request.Error(", strconv.Quote("560"), ", ", strconv.Quote("Failed to unmarshal proto message"), ", []byte(err.Error()))")
			g.P("return")
			g.P("}")
			g.P()
		}
		var handlerResp string
		if method.Output.Location.SourceFile != emptyPb {
			handlerResp = "response, "
		}
		g.P(handlerResp, "err := impl.", method.GoName, "(", handlerReq, ")")
		g.P("if err != nil {")
		g.P("if serverErr, ok := err.(", goNatsPkg.Ident("ServerError"), "); ok {")
		g.P("request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())")
		g.P("} else {")
		g.P("request.Error(", strconv.Quote("500"), ", ", strconv.Quote("Internal server error"), ", []byte(err.Error()))")
		g.P("}")
		g.P("return")
		g.P("}")
		g.P()
		if method.Output.Location.SourceFile != emptyPb {
			g.P("data, err := ", protoMarshal, "(response)")
			g.P("if err != nil {")
			g.P("request.Error(", strconv.Quote("560"), ", ", strconv.Quote("Failed to marshal proto message"), ", []byte(err.Error()))")
			g.P("return")
			g.P("}")
			g.P("request.Respond(data)")
		} else {
			g.P("request.Respond(nil)")
		}
		g.P("})")

		g.P("err = service.AddEndpoint(", strconv.Quote(method.GoName), ", ", handler, ", ", microPkg.Ident("WithEndpointSubject"), "(", strconv.Quote(subjectName(service, method)), "))")
		g.P("if err != nil {")
		g.P("panic(err) // TODO: Update this to proper error handling")
		g.P("}")

		g.P("err = service.AddEndpoint(", strconv.Quote(method.GoName+"-Direct"), ", ", handler, ", ", microPkg.Ident("WithEndpointSubject"), "(", strconv.Quote(subjectName(service, method)+"."), " + service.Info().ID))")
		g.P("if err != nil {")
		g.P("panic(err) // TODO: Update this to proper error handling")
		g.P("}")
		g.P()
	}

	g.P("return service")
	g.P("}")
	g.P("//endregion")
}

func generateClient(g *protogen.GeneratedFile, service *protogen.Service) {
	cliName := service.GoName + "NATSClient"

	// Generate client interface
	g.P("//region Client")
	g.AnnotateSymbol(cliName, protogen.Annotation{Location: service.Location}) // TODO: Find out when to annotate symbols
	g.P("type ", cliName, " interface {")
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			// TODO: Skipping currently unsupported streaming methods for now
			g.P("// ", method.GoName, " is a streaming method and is currently not supported")
			continue
		}
		// Check if method.GoName is in reservedKeywords
		if _, ok := reservedKeywords[strings.ToLower(method.GoName)]; ok {
			g.P("// ", method.GoName, " is a reserved keyword and cannot be used as a method name")
			continue
		}
		var req, resp string
		if method.Input.Location.SourceFile != emptyPb {
			req = "req *" + g.QualifiedGoIdent(method.Input.GoIdent) + ", "
		}
		if method.Output.Location.SourceFile != emptyPb {
			resp = "*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", "
		}
		g.AnnotateSymbol(cliName+"."+method.GoName, protogen.Annotation{Location: method.Location})
		g.P(method.Comments.Leading, method.GoName, "(", req, "opts ...CallOption) (", resp, "error)")
	}
	g.P("SetTimeout(", timeDuration, ")")
	g.P("// ListInstances returns a list containing all instances of this service")
	g.P("// This is a convenience method that calls Ping with no options")
	g.P("ListInstances() ([]*Ping, error)")
	g.P("// Ping sends a ping to either all instances or a specific instance of this service")
	g.P("Ping(opts ...CallOption) ([]*Ping, error)")
	g.P("// Stats returns the stats of either all instances or a specific instance of this service")
	g.P("Stats(opts ...CallOption) ([]*micro.Stats, error)")
	g.P("// Info returns the info of either all instances or a specific instance of this service")
	g.P("Info(opts ...CallOption) ([]*micro.Info, error)")
	g.P("}")
	g.P()

	// Generate Ping struct
	g.P("type Ping struct {")
	g.P(microPkg.Ident("ServiceIdentity"))
	g.P("Type string")
	g.P("RTT ", timeDuration)
	g.P("}")
	g.P()

	// Generate CallOption type and functions
	g.P("//region CallOptions")
	g.P("type CallOption func(*callOptions)")
	g.P()
	g.P("type callOptions struct {")
	g.P("instanceID string")
	g.P("timeout ", timeDuration)
	g.P("}")
	g.P()
	g.P("func (opts *callOptions) hasInstanceID() bool {")
	g.P("return opts.instanceID != \"\"")
	g.P("}")
	g.P()
	g.P("func WithInstanceID(id string) CallOption {")
	g.P("return func(opts *callOptions) {")
	g.P("opts.instanceID = id")
	g.P("}")
	g.P("}")
	g.P()
	g.P("func WithTimeout(timeout ", timeDuration, ") CallOption {")
	g.P("return func(options *callOptions) {")
	g.P("options.timeout = timeout")
	g.P("}")
	g.P("}")
	g.P()
	g.P("func process(opts ...CallOption) callOptions {")
	g.P("options := callOptions{}")
	g.P("for _, opt := range opts {")
	g.P("opt(&options)")
	g.P("}")
	g.P("return options")
	g.P("}")
	g.P("//endregion")
	g.P()

	// Generate client struct implementation
	g.P("type ", unexport(cliName), " struct {")
	g.P("nc *", natsConn)
	g.P("timeout ", timeDuration)
	g.P("}")
	g.P()

	// Client struct functions

	// Generate SetTimeout function
	g.P("func (c *", unexport(cliName), ") SetTimeout(timeout ", timeDuration, ") {")
	g.P("c.timeout = timeout")
	g.P("}")
	g.P()

	// Generate ListInstances function
	g.P("func (c *", unexport(cliName), ") ListInstances() ([]*Ping, error) {")
	g.P("return c.Ping()")
	g.P("}")
	g.P()

	// Generate Ping/Stats/Info functions
	generateReqFunc(g, cliName, service.GoName, "Stats", microPkg.Ident("Stats"), microPkg.Ident("StatsVerb"))
	generateReqFunc(g, cliName, service.GoName, "Info", microPkg.Ident("Info"), microPkg.Ident("InfoVerb"))
	generateReqFunc(g, cliName, service.GoName, "Ping", "Ping", microPkg.Ident("PingVerb"))

	// Generate handle function
	g.P("func (c *", unexport(cliName), ") handle(req ", protoMessage, ", subject string, out ", protoMessage, ", timeout ", timeDuration, ") (err error) {")
	g.P("var data []byte")
	g.P("if req != nil {")
	g.P("if data, err = ", protoMarshal, "(req); err != nil {")
	g.P("return ", goNatsPkg.Ident("ErrMarshallingFailed"))
	g.P("}")
	g.P("}")
	g.P("msg, err := c.nc.Request(subject, data, timeout)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("errMsg, errCode := msg.Header.Get(", microPkg.Ident("ErrorHeader"), "), msg.Header.Get(", microPkg.Ident("ErrorCodeHeader"), ")")
	g.P("if len(errMsg) > 0 && len(errCode) > 0 {")
	g.P("if len(msg.Data) == 0 {")
	g.P("return ", goNatsPkg.Ident("ServiceError"), "{errCode, errMsg, \"\"}")
	g.P("}")
	g.P("return ", goNatsPkg.Ident("ServiceError"), "{errCode, errMsg, string(msg.Data)}")
	g.P("}")
	g.P("if out != nil {")
	g.P("if err = ", protoUnmarshal, "(msg.Data, out); err != nil {")
	g.P("return ", goNatsPkg.Ident("ErrUnmarshallingFailed"))
	g.P("}")
	g.P("}")
	g.P("return nil")
	g.P("}")
	g.P()

	// Generate request function
	g.P("func request[T any](conn *", natsConn, ", timeout ", timeDuration, ", subject string, collector func([]byte, ", timeDuration, ") (*T, error)) ([]*T, error) {")
	g.P("ctx, cancel := ", protogen.GoImportPath("context").Ident("WithTimeout"), "(", protogen.GoImportPath("context").Ident("Background"), "(), timeout)")
	g.P("defer cancel()")
	g.P()
	g.P("timer := ", timePkg.Ident("NewTimer"), "(timeout)")
	g.P("go func() {")
	g.P("// Select whatever happens first")
	g.P("select {")
	g.P("// if timer runs out first, cancel the 5 second context")
	g.P("case <-timer.C:")
	g.P("cancel()")
	g.P("// if context is done already, do nothing, maybe stop timer")
	g.P("case <-ctx.Done():")
	g.P("timer.Stop()")
	g.P("return")
	g.P("}")
	g.P("}()")
	g.P("var start ", timePkg.Ident("Time"))
	g.P("res := []*T{}")
	g.P("mu := ", protogen.GoImportPath("sync").Ident("Mutex"), "{}")
	g.P("errs := make(chan error)")
	g.P("sub, err := conn.Subscribe(conn.NewRespInbox(), func(msg *", natsPkg.Ident("Msg"), ") {")
	g.P("mu.Lock()")
	g.P("defer mu.Unlock()")
	g.P()
	g.P("rtt := ", timePkg.Ident("Since"), "(start)")
	g.P("if msg.Header.Get(\"Status\") == \"503\" {")
	g.P("errs <- ", natsPkg.Ident("ErrNoResponders"))
	g.P("return")
	g.P("}")
	g.P()
	g.P("timer.Reset(300 * ", timePkg.Ident("Millisecond"), ")")
	g.P("if col, err := collector(msg.Data, rtt); err != nil {")
	g.P("errs <- err")
	g.P("} else {")
	g.P("res = append(res, col)")
	g.P("}")
	g.P("})")
	g.P("if err != nil {")
	g.P("return nil, err")
	g.P("}")
	g.P("defer sub.Unsubscribe()")
	g.P()
	g.P("start = ", timePkg.Ident("Now"), "()")
	g.P("err = conn.PublishRequest(subject, sub.Subject, nil)")
	g.P("if err != nil {")
	g.P("return nil, err")
	g.P("}")
	g.P()
	g.P("select {")
	g.P("case err = <-errs:")
	g.P("return nil, err")
	g.P("case <-ctx.Done():")
	g.P("}")
	g.P()
	g.P("return res, nil")
	g.P("}")
	g.P()

	// Generate NewClient function
	g.P("func New", cliName, "(nc *", natsConn, ") ", cliName, " {")
	g.P("return &", unexport(cliName), "{nc: nc, timeout: ", timePkg.Ident("Second"), " * 5}")
	g.P("}")
	g.P()

	// Generate client methods
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			// TODO: Skipping currently unsupported streaming methods for now
			continue
		}
		// Check if method.GoName is in reservedKeywords
		if _, ok := reservedKeywords[strings.ToLower(method.GoName)]; ok {
			continue
		}

		var req, resp, handleReq, handleResp, returnResp string
		if method.Input.Location.SourceFile != emptyPb {
			req = "req *" + g.QualifiedGoIdent(method.Input.GoIdent) + ", "
			handleReq = "req"
		} else {
			handleReq = "nil"
		}
		if method.Output.Location.SourceFile != emptyPb {
			resp = "*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", "
			handleResp = "&response"
			returnResp = "&response, "
		} else {
			handleResp = "nil"
			returnResp = ""
		}
		g.P("func (c *", unexport(cliName), ") ", method.GoName, "(", req, "opts ...CallOption) (", resp, "error) {")
		g.P("options := process(opts...)")
		if method.Output.Location.SourceFile != emptyPb {
			g.P("var response ", method.Output.GoIdent)
		}
		g.P("var err error")
		g.P()
		g.P("timeout := c.timeout")
		g.P("if options.timeout != 0 {")
		g.P("	timeout = options.timeout")
		g.P("}")
		g.P()
		g.P("if options.hasInstanceID() {")
		g.P("err = c.handle(", handleReq, ", ", strconv.Quote(subjectName(service, method)+"."), " + options.instanceID, ", handleResp, ", timeout)")
		g.P("} else {")
		g.P("err = c.handle(", handleReq, ", ", strconv.Quote(subjectName(service, method)), ", ", handleResp, ", timeout)")
		g.P("}")
		g.P("return ", returnResp, "err")
		g.P("}")
		g.P()
	}

	g.P("//endregion")
	g.P()
}

func generateReqFunc(g *protogen.GeneratedFile, cliName, goName, method string, T any, verb any) {
	g.P("func (c *", unexport(cliName), ") ", method, "(opts ...CallOption) ([]*", T, ", error) {")
	g.P("options := process(opts...)")
	g.P("var subject string")
	g.P()

	g.P("timeout := c.timeout")
	g.P("if options.timeout != 0 {")
	g.P("	timeout = options.timeout")
	g.P("}")
	g.P()

	g.P("if options.hasInstanceID() {")
	g.P("subject = ", protogen.GoImportPath("fmt").Ident("Sprintf"), "(\"%s.%s.%s.%s\", ", microPkg.Ident("APIPrefix"), ", ", verb, ", ", strconv.Quote(goName), ", options.instanceID)")
	g.P("} else {")
	g.P("subject = ", protogen.GoImportPath("fmt").Ident("Sprintf"), "(\"%s.%s.%s\", ", microPkg.Ident("APIPrefix"), ", ", verb, ", ", strconv.Quote(goName), ")")
	g.P("}")

	g.P("objs, err := request(c.nc, timeout, subject, func(data []byte, rtt ", timeDuration, ") (*", T, ", error) {")
	g.P("var obj ", T)
	g.P("if err := ", protogen.GoImportPath("encoding/json").Ident("Unmarshal"), "(data, &obj); err != nil {")
	g.P("return nil, err")
	g.P("}")
	if method == "Ping" {
		g.P("obj.RTT = rtt")
	}
	g.P("return &obj, nil")
	g.P("})")
	g.P("if err != nil {")
	g.P("return nil, err")
	g.P("}")
	g.P("return objs, nil")
	g.P("}")
	g.P()
}

func generateService(g *protogen.GeneratedFile, service *protogen.Service) {
	generateClient(g, service)
	generateServer(g, service)
}

func subjectName(service *protogen.Service, method *protogen.Method) string {
	return "service." + service.GoName + "." + method.GoName
}
