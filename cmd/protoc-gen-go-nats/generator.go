package main

import (
	"errors"
	"fmt"
	"github.com/nats-io/nats.go/micro"
	"google.golang.org/protobuf/compiler/protogen"
	"strconv"
	"strings"
	"xiam.li/protonats/go/plugin"
	"xiam.li/protonats/go/protonats"
)

const (
	natsPkg       = protogen.GoImportPath("github.com/nats-io/nats.go")
	microPkg      = protogen.GoImportPath("github.com/nats-io/nats.go/micro")
	nuidPkg       = protogen.GoImportPath("github.com/nats-io/nuid")
	timePkg       = protogen.GoImportPath("time")
	protoPkg      = protogen.GoImportPath("google.golang.org/protobuf/proto")
	goNatsPkg     = protogen.GoImportPath("xiam.li/protonats/go/protonats")
	goNatsImplPkg = protogen.GoImportPath("xiam.li/protonats/go/impl")
	errorsPkg     = protogen.GoImportPath("errors")
	slogPkg       = protogen.GoImportPath("log/slog")
	contextPkg    = protogen.GoImportPath("context")
)

var (
	natsConn       = natsPkg.Ident("Conn")
	microRequest   = microPkg.Ident("Request")
	timeDuration   = timePkg.Ident("Duration")
	protoMessage   = protoPkg.Ident("Message")
	protoMarshal   = protoPkg.Ident("Marshal")
	protoUnmarshal = protoPkg.Ident("Unmarshal")

	emptyPb = "google/protobuf/empty.proto"

	// reservedKeywords is a map of reserved keywords that cannot be used as method names
	reservedKeywords = map[string]struct{}{
		"listinstances": {},
		"ping":          {},
		"stats":         {},
		"info":          {},
	}
)

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

func generateFile(gen *protogen.Plugin, file *protogen.File) error {
	if len(file.Services) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + "_nats.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-nats. DO NOT EDIT.")
	g.P("// Versions:")
	g.P("// - protoc-gen-go-nats ", version)
	g.P("// - protoc        v", protocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	for _, service := range file.Services {
		if err := generateService(g, service); err != nil {
			return err
		}
	}
	return nil
}

func generateServer(g *protogen.GeneratedFile, service *protogen.Service) error {
	srvName := service.GoName + "NATSServer"

	var leaderMethods, followerMethods []string

	// Generate server interface
	g.P("//region Server")
	g.P("type ", srvName, " interface {")
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			// TODO: Skipping currently unsupported streaming methods for now
			g.P("// ", method.GoName, " is a streaming method and is currently not supported")
			continue
		}
		// Check if method.GoName is in reservedKeywords
		if _, ok := reservedKeywords[strings.ToLower(method.GoName)]; ok {
			g.P("// ", method.GoName, " is a reserved keyword and cannot be used as a method name")
			continue
		}
		var req, resp string
		if method.Input.Location.SourceFile != emptyPb {
			req = "req *" + g.QualifiedGoIdent(method.Input.GoIdent)
		}
		if method.Output.Location.SourceFile != emptyPb {
			resp = "*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", "
		}
		fn := fmt.Sprintf("%s%s(%s) (%serror)", method.Comments.Leading, method.GoName, req, resp)

		if consensusTarget := plugin.GetConsensusTarget(method); consensusTarget != nil {
			if *consensusTarget == protonats.ConsensusTarget_LEADER {
				leaderMethods = append(leaderMethods, fn)
			} else {
				followerMethods = append(followerMethods, fn)
			}
		} else {
			g.P(fn)
		}
	}
	if len(leaderMethods) > 0 {
		g.P(service.GoName, "NATSLeaderServer")
	}
	if len(followerMethods) > 0 {
		g.P(service.GoName, "NATSFollowerServer")
	}

	g.P("}")
	g.P()

	// Generate Follower/leader interface if there are any consensus-based methods
	if len(leaderMethods) > 0 {
		g.P("type ", service.GoName, "NATSLeaderServer interface {")
		for _, method := range leaderMethods {
			g.P(method)
		}
		g.P("}")
		g.P()
	}
	if len(followerMethods) > 0 {
		g.P("type ", service.GoName, "NATSFollowerServer interface {")
		for _, method := range followerMethods {
			g.P(method)
		}
		g.P("}")
		g.P()
	}

	// Generate SetId interface
	g.P("type ", service.GoName, "Id interface {")
	g.P("Set", service.GoName, "Id(string)")
	g.P("}")
	g.P()

	// Generate NewServer function
	g.P("func New", srvName, "(nc *", natsConn, ", server ", srvName, ", opts ...", goNatsPkg.Ident("ServerOption"), ") ", microPkg.Ident("Service"), " {")
	g.P("service, options, err := ", goNatsImplPkg.Ident("NewService"), "(", strconv.Quote(service.GoName), ", nc, server, opts...)")
	g.P("if err != nil {")
	g.P("panic(err) // TODO: Update this to proper error handling")
	g.P("}")
	g.P("if setId, ok := server.(", service.GoName, "Id); ok {")
	g.P("setId.Set", service.GoName, "Id(service.Info().ID)")
	g.P("}")

	g.P("_new", service.GoName, "Server(service, server, options)")
	g.P()

	if len(leaderMethods) > 0 {
		g.P("if !options.WithoutLeaderFunctions {")
		g.P("_new", service.GoName, "LeaderServer(service, server, options)")
		g.P("}")
	}
	if len(followerMethods) > 0 {
		g.P("if !options.WithoutFollowerFunctions {")
		g.P("_new", service.GoName, "FollowerServer(service, server, options)")
		g.P("}")
	}
	g.P("return service")
	g.P("}")

	g.P("func _new", service.GoName, "Server(service micro.Service, server ", service.GoName, "NATSServer, opts *", goNatsImplPkg.Ident("ServerOpts"), ") {")
	g.P("var err error")
	g.P("_ = err") // In case there are no more methods so that err isn't unused
	g.P()

	// Generate service endpoints
	g.P("// Register the service's methods")
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			// TODO: Skipping currently unsupported streaming methods for now
			continue
		}
		if plugin.GetConsensusTarget(method) != nil {
			continue
		}
		generateEndpointHandler(g, service, method)
	}

	g.P("}")
	g.P()

	// Generate NewLeaderServer function
	if len(leaderMethods) > 0 {
		g.P("func New", service.GoName, "NATSLeaderServer(nc *", natsConn, ", server ", service.GoName, "NATSLeaderServer, opts ...", goNatsPkg.Ident("ServerOption"), ") ", microPkg.Ident("Service"), " {")
		g.P("service, options, err := ", goNatsImplPkg.Ident("NewService"), "(", strconv.Quote(service.GoName), ", nc, server, opts...)")
		g.P("if err != nil {")
		g.P("panic(err) // TODO: Update this to proper error handling")
		g.P("}")
		g.P("if setId, ok := server.(", service.GoName, "Id); ok {")
		g.P("setId.Set", service.GoName, "Id(service.Info().ID)")
		g.P("}")
		g.P("_new", service.GoName, "LeaderServer(service, server, options)")
		g.P("return service")
		g.P("}")
		g.P()

		g.P("func _new", service.GoName, "LeaderServer(service micro.Service, server ", service.GoName, "NATSLeaderServer, opts *", goNatsImplPkg.Ident("ServerOpts"), ") {")
		g.P("var err error")
		g.P("_ = err") // In case there are no more methods so that err isn't unused

		for _, method := range service.Methods {
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				// TODO: Skipping currently unsupported streaming methods for now
				continue
			}
			if plugin.IsConsensusLeader(method) {
				generateEndpointHandler(g, service, method)
			}
		}
		g.P("}")
		g.P()
	}

	// Generate NewFollowerServer function
	if len(followerMethods) > 0 {
		g.P("func New", service.GoName, "NATSFollowerServer(nc *", natsConn, ", server ", service.GoName, "NATSFollowerServer, opts ...", goNatsPkg.Ident("ServerOption"), ") ", microPkg.Ident("Service"), " {")
		g.P("service, options, err := ", goNatsImplPkg.Ident("NewService"), "(", strconv.Quote(service.GoName), ", nc, server, opts...)")
		g.P("if err != nil {")
		g.P("panic(err) // TODO: Update this to proper error handling")
		g.P("}")
		g.P("if setId, ok := server.(", service.GoName, "Id); ok {")
		g.P("setId.Set", service.GoName, "Id(service.Info().ID)")
		g.P("}")
		g.P("_new", service.GoName, "FollowerServer(service, server, options)")
		g.P("return service")
		g.P("}")
		g.P()

		g.P("func _new", service.GoName, "FollowerServer(service micro.Service, server ", service.GoName, "NATSFollowerServer, opts *", goNatsImplPkg.Ident("ServerOpts"), ") {")
		g.P("var err error")
		g.P("_ = err") // In case there are no more methods so that err isn't unused

		for _, method := range service.Methods {
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				// TODO: Skipping currently unsupported streaming methods for now
				continue
			}
			if plugin.IsConsensusFollower(method) {
				generateEndpointHandler(g, service, method)
			}
		}
		g.P("}")
		g.P()
	}
	g.P("//endregion")
	return nil
}

func generateEndpointHandler(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) {
	handler := method.GoName + "Handler"
	g.P(handler, " := ", microPkg.Ident("HandlerFunc"), "(func(request ", microRequest, ") {")

	var handlerReq string
	if method.Input.Location.SourceFile != emptyPb {
		handlerReq = "&req"
		g.P("var req ", method.Input.GoIdent)
		g.P("if err := ", protoUnmarshal, "(request.Data(), &req); err != nil {")
		g.P("request.Error(", strconv.Quote("560"), ", ", strconv.Quote("Failed to unmarshal proto message"), ", []byte(err.Error()))")
		g.P("return")
		g.P("}")
		g.P()
	}
	var handlerResp string
	if method.Output.Location.SourceFile != emptyPb {
		handlerResp = "response, "
	}
	g.P(handlerResp, "err := server.", method.GoName, "(", handlerReq, ")")
	g.P("if err != nil {")
	g.P("if ", goNatsPkg.Ident("IsServiceError"), "(err) {")
	g.P(slogPkg.Ident("Warn"), "(", strconv.Quote("Server implementations should not return ServiceError, use go_nats.NewServerError instead"), ", ", strconv.Quote("error"), ", err)")
	g.P("}")
	g.P("var serverErr ", goNatsPkg.Ident("ServerError"))
	g.P("if ", errorsPkg.Ident("As"), "(err, &serverErr) {")
	g.P("request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())")
	g.P("} else {")
	g.P("request.Error(", strconv.Quote("500"), ", ", strconv.Quote("Internal server error"), ", []byte(err.Error()))")
	g.P("}")
	g.P("return")
	g.P("}")
	g.P()
	if method.Output.Location.SourceFile != emptyPb {
		g.P("data, err := ", protoMarshal, "(response)")
		g.P("if err != nil {")
		g.P("request.Error(", strconv.Quote("560"), ", ", strconv.Quote("Failed to marshal proto message"), ", []byte(err.Error()))")
		g.P("return")
		g.P("}")
		g.P("request.Respond(data)")
	} else {
		g.P("request.Respond(nil)")
	}
	g.P("})")

	if plugin.IsUsingBroadcasting(method) {
		// Add a broadcast endpoint for the method
		g.P("err = service.AddEndpoint(", strconv.Quote(method.GoName+"-Broadcast"), ", ", handler, ", ", microPkg.Ident("WithEndpointQueueGroup"), "(", nuidPkg.Ident("Next"), "()), opts.Subject(", strconv.Quote(subjectName(service, method)), ", ", strconv.Quote(""), "))")
	} else {
		// Add a shared endpoint for the method
		g.P("err = service.AddEndpoint(", strconv.Quote(method.GoName), ", ", handler, ", opts.Subject(", strconv.Quote(subjectName(service, method)), ", ", strconv.Quote(""), "))")
		g.P("if err != nil {")
		g.P("panic(err) // TODO: Update this to proper error handling")
		g.P("}")

		// Add a direct endpoint for the method
		g.P("err = service.AddEndpoint(", strconv.Quote(method.GoName+"-Direct"), ", ", handler, ", opts.Subject(", strconv.Quote(subjectName(service, method)), ", service.Info().ID))")
		g.P("if err != nil {")
		g.P("panic(err) // TODO: Update this to proper error handling")
		g.P("}")
	}
	g.P()
}

func generateClient(g *protogen.GeneratedFile, service *protogen.Service) error {
	cliName := service.GoName + "NATSClient"

	// Generate client interface
	g.P("//region Client")
	g.AnnotateSymbol(cliName, protogen.Annotation{Location: service.Location}) // TODO: Find out when to annotate symbols
	g.P("type ", cliName, " interface {")
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			// TODO: Skipping currently unsupported streaming methods for now
			g.P("// ", method.GoName, " is a streaming method and is currently not supported")
			continue
		}
		// Check if method.GoName is in reservedKeywords
		if _, ok := reservedKeywords[strings.ToLower(method.GoName)]; ok {
			return errors.New("reserved keyword '" + method.GoName + "' used as method name")
		}
		broadcasting := plugin.IsUsingBroadcasting(method)
		var req, resp string
		if method.Input.Location.SourceFile != emptyPb {
			req = "req *" + g.QualifiedGoIdent(method.Input.GoIdent) + ", "
		}
		if method.Output.Location.SourceFile != emptyPb {
			var prefix string
			if broadcasting {
				prefix = "[]"
			}
			resp = prefix + "*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", "
		}
		g.AnnotateSymbol(cliName+"."+method.GoName, protogen.Annotation{Location: method.Location})
		if broadcasting {
			g.P(method.Comments.Leading, method.GoName, "(", req, "opts ...", goNatsPkg.Ident("CallOption"), ") (", resp, "[]", goNatsPkg.Ident("ServiceError"), ", error)")
		} else {
			g.P(method.Comments.Leading, method.GoName, "(", req, "opts ...", goNatsPkg.Ident("CallOption"), ") (", resp, "error)")
		}
	}
	g.P("SetTimeout(", timeDuration, ")")
	g.P("// ListInstances returns a list containing all instances of this service")
	g.P("// This is a convenience method that calls ", goNatsPkg.Ident("Ping"), " with no options")
	g.P("ListInstances() ([]*", goNatsPkg.Ident("Ping"), ", error)")
	g.P("// Ping sends a ping to either all instances or a specific instance of this service")
	g.P("Ping(opts ...", goNatsPkg.Ident("CallOption"), ") ([]*", goNatsPkg.Ident("Ping"), ", error)")
	g.P("// Stats returns the stats of either all instances or a specific instance of this service")
	g.P("Stats(opts ...", goNatsPkg.Ident("CallOption"), ") ([]*micro.Stats, error)")
	g.P("// Info returns the info of either all instances or a specific instance of this service")
	g.P("Info(opts ...", goNatsPkg.Ident("CallOption"), ") ([]*micro.Info, error)")
	g.P("}")
	g.P()

	// Generate client struct implementation
	g.P("type ", unexport(cliName), " struct {")
	g.P("nc *", natsConn)
	g.P("timeout ", timeDuration)
	g.P("}")
	g.P()

	// Client struct functions

	// Generate SetTimeout function
	g.P("func (c *", unexport(cliName), ") SetTimeout(timeout ", timeDuration, ") {")
	g.P("c.timeout = timeout")
	g.P("}")
	g.P()

	// Generate ListInstances function
	g.P("func (c *", unexport(cliName), ") ListInstances() ([]*", goNatsPkg.Ident("Ping"), ", error) {")
	g.P("return c.Ping()")
	g.P("}")
	g.P()

	// Generate Ping/Stats/Info functions
	generateReqFunc(g, cliName, service.GoName, "Stats", microPkg.Ident("Stats"), micro.StatsVerb)
	generateReqFunc(g, cliName, service.GoName, "Info", microPkg.Ident("Info"), micro.InfoVerb)
	generateReqFunc(g, cliName, service.GoName, "Ping", goNatsPkg.Ident("Ping"), micro.PingVerb)

	// Generate handle with retry function
	g.P("func (c *", unexport(cliName), ") handleWithRetry(req ", protoMessage, ", subject string, out ", protoMessage, ", opts ...", goNatsPkg.Ident("CallOption"), ") (err error) {")
	g.P("options := ", goNatsImplPkg.Ident("ProcessCallOptions"), "(opts...)")
	g.P("timeout := options.GetTimeoutOr(c.timeout)")
	g.P()
	g.P("var tries int")
	g.P("for {")
	g.P("err = c.handle(options.Context, req, options.Subject(subject), out, timeout)")
	g.P("if err == nil || !errors.Is(err, ", natsPkg.Ident("ErrNoResponders"), ") {")
	g.P("return")
	g.P("}")
	g.P("tries++")
	g.P("if options.Context.Err() != nil {")
	g.P("err = ", errorsPkg.Ident("Join"), "(err, options.Context.Err())")
	g.P("return")
	g.P("}")
	g.P("if !options.ShouldRetry() {")
	g.P("return")
	g.P("}")
	g.P("if tries >= options.Retries {")
	g.P("err = ", errorsPkg.Ident("New"), "(", strconv.Quote("Failed to call service after max tries: "), "+ err.Error())")
	g.P("return")
	g.P("}")
	g.P("time.Sleep(options.RetryDelay)")
	g.P("}")
	g.P("}")

	// Generate handle function
	g.P("func (c *", unexport(cliName), ") handle(ctx ", contextPkg.Ident("Context"), ", req ", protoMessage, ", subject string, out ", protoMessage, ", timeout ", timeDuration, ") (err error) {")
	g.P("var data []byte")
	g.P("if req != nil {")
	g.P("if data, err = ", protoMarshal, "(req); err != nil {")
	g.P("return ", goNatsPkg.Ident("ErrMarshallingFailed"))
	g.P("}")
	g.P("}")
	g.P("var msg *", natsPkg.Ident("Msg"))
	g.P("if ctx == nil {")
	g.P("msg, err = c.nc.Request(subject, data, timeout)")
	g.P("} else {")
	g.P("msg, err = c.nc.RequestWithContext(ctx, subject, data)")
	g.P("}")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("if errMsg, errCode := msg.Header.Get(", microPkg.Ident("ErrorHeader"), "), msg.Header.Get(", microPkg.Ident("ErrorCodeHeader"), "); len(errMsg) > 0 && len(errCode) > 0 {")
	g.P("if len(msg.Data) == 0 {")
	g.P("return ", goNatsPkg.Ident("ServiceError"), "{errCode, errMsg, \"\"}")
	g.P("}")
	g.P("return ", goNatsPkg.Ident("ServiceError"), "{errCode, errMsg, string(msg.Data)}")
	g.P("}")
	g.P("if out != nil {")
	g.P("if err = ", protoUnmarshal, "(msg.Data, out); err != nil {")
	g.P("return ", goNatsPkg.Ident("ErrUnmarshallingFailed"))
	g.P("}")
	g.P("}")
	g.P("return nil")
	g.P("}")
	g.P()

	// Generate request function
	g.P("func request[T any](conn *", natsConn, ", timeout ", timeDuration, ", subject string, data []byte, collector func([]byte, ", timeDuration, ") (*T, error), opts ...", goNatsPkg.Ident("CallOption"), ") ([]*T, []", goNatsPkg.Ident("ServiceError"), ", error) {")
	g.P("options := ", goNatsImplPkg.Ident("ProcessCallOptions"), "(opts...)")
	g.P("timeout = options.GetTimeoutOr(timeout)")
	g.P()
	g.P("ctx, cancel := ", protogen.GoImportPath("context").Ident("WithTimeout"), "(options.Ctx(), timeout)")
	g.P("defer cancel()")
	g.P()
	g.P("timer := ", timePkg.Ident("NewTimer"), "(timeout)")
	g.P("go func() {")
	g.P("select {")
	g.P("case <-timer.C:")
	g.P("cancel()")
	g.P("case <-ctx.Done():")
	g.P("timer.Stop()")
	g.P("return")
	g.P("}")
	g.P("}()")
	g.P("var start ", timePkg.Ident("Time"))
	g.P("res := []*T{}")
	g.P("mu := ", protogen.GoImportPath("sync").Ident("Mutex"), "{}")
	g.P("errCh := make(chan error)")
	g.P("serviceErrs := []", goNatsPkg.Ident("ServiceError"), "{}")
	g.P("var finisher *", timePkg.Ident("Timer"))
	g.P("if !options.DisableFinisher {")
	g.P("finisher = ", timePkg.Ident("NewTimer"), "(timeout)")
	g.P("go func() {")
	g.P("select {")
	g.P("case <-finisher.C:")
	g.P("cancel()")
	g.P("case <-ctx.Done():")
	g.P("return")
	g.P("}")
	g.P("}()")
	g.P("}")
	g.P("sub, err := conn.Subscribe(conn.NewRespInbox(), func(msg *", natsPkg.Ident("Msg"), ") {")
	g.P("mu.Lock()")
	g.P("defer mu.Unlock()")
	g.P()
	g.P("rtt := ", timePkg.Ident("Since"), "(start)")
	g.P("if msg.Header.Get(\"Status\") == \"503\" {")
	g.P("errCh <- ", natsPkg.Ident("ErrNoResponders"))
	g.P("return")
	g.P("}")
	g.P()
	g.P("if finisher != nil {")
	g.P("finisher.Reset(250 * ", timePkg.Ident("Millisecond"), ")")
	g.P("}")
	g.P()
	g.P("if errMsg, errCode := msg.Header.Get(", microPkg.Ident("ErrorHeader"), "), msg.Header.Get(", microPkg.Ident("ErrorCodeHeader"), "); len(errMsg) > 0 && len(errCode) > 0 {")
	g.P("if len(msg.Data) == 0 {")
	g.P("serviceErrs = append(serviceErrs, ", goNatsPkg.Ident("ServiceError"), "{Code: errCode, Description: errMsg})")
	g.P("} else {")
	g.P("serviceErrs = append(serviceErrs, ", goNatsPkg.Ident("ServiceError"), "{Code: errCode, Description: errMsg, Details: string(msg.Data)})")
	g.P("}")
	g.P("return")
	g.P("}")
	g.P("if collector != nil {")
	g.P("if col, err := collector(msg.Data, rtt); err != nil {")
	g.P("errCh <- err")
	g.P("} else {")
	g.P("res = append(res, col)")
	g.P("}")
	g.P("}")
	g.P("})")
	g.P("if err != nil {")
	g.P("return nil, nil, err")
	g.P("}")
	g.P("defer sub.Unsubscribe()")
	g.P()
	g.P("start = ", timePkg.Ident("Now"), "()")
	g.P("err = conn.PublishRequest(options.Subject(subject), sub.Subject, data)")
	g.P("if err != nil {")
	g.P("return nil, nil, err")
	g.P("}")
	g.P()
	g.P("select {")
	g.P("case err = <-errCh:")
	g.P("return nil, serviceErrs, err")
	g.P("case <-ctx.Done():")
	g.P("return res, serviceErrs, nil")
	g.P("}")
	g.P("}")
	g.P()

	// Generate NewClient function
	g.P("func New", cliName, "(nc *", natsConn, ") ", cliName, " {")
	g.P("return &", unexport(cliName), "{nc: nc, timeout: ", timePkg.Ident("Second"), " * 5}")
	g.P("}")
	g.P()

	// Generate client methods
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			// TODO: Skipping currently unsupported streaming methods for now
			continue
		}
		broadcasting := plugin.IsUsingBroadcasting(method)

		var req, resp, handleReq, handleResp, returnResp string
		if method.Input.Location.SourceFile != emptyPb {
			req = "req *" + g.QualifiedGoIdent(method.Input.GoIdent) + ", "
			handleReq = "req"
		} else {
			handleReq = "nil"
		}
		if method.Output.Location.SourceFile != emptyPb {
			var prefix string
			if broadcasting {
				prefix = "[]"
			}
			resp = prefix + "*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", "
			handleResp = "&response"
			returnResp = "&response, "
		} else {
			handleResp = "nil"
			returnResp = ""
		}
		if broadcasting {
			g.P("func (c *", unexport(cliName), ") ", method.GoName, "(", req, "opts ...", goNatsPkg.Ident("CallOption"), ") (", resp, "[]", goNatsPkg.Ident("ServiceError"), ", error) {")
		} else {
			g.P("func (c *", unexport(cliName), ") ", method.GoName, "(", req, "opts ...", goNatsPkg.Ident("CallOption"), ") (", resp, "error) {")
		}

		if method.Output.Location.SourceFile != emptyPb && !broadcasting {
			g.P("var response ", method.Output.GoIdent)
			g.P()
		}

		if broadcasting {
			var input string
			if method.Input.Location.SourceFile != emptyPb {
				var returnResp string
				if method.Output.Location.SourceFile != emptyPb {
					returnResp = "nil, "
				}
				g.P("var data []byte")
				g.P("if req != nil {")
				g.P("var err error")
				g.P("if data, err = ", protoMarshal, "(req); err != nil {")
				g.P("return ", returnResp, "nil, ", goNatsPkg.Ident("ErrMarshallingFailed"))
				g.P("}")
				g.P("}")
				input = "data"
			} else {
				input = "nil"
			}

			if method.Output.Location.SourceFile != emptyPb {
				g.P("objs, serviceErrs, err := request(c.nc, c.timeout, ", strconv.Quote(subjectName(service, method)), ", ", input, ", func(data []byte, rtt ", timeDuration, ") (*", method.Output.GoIdent, ", error) {")
				g.P("var obj ", method.Output.GoIdent)
				g.P("if err := ", protoUnmarshal, "(data, &obj); err != nil {")
				g.P("return nil, err")
				g.P("}")
				g.P("return &obj, nil")
				g.P("}, opts...)")
				g.P("return objs, serviceErrs, err")
			} else {
				g.P("_, serviceErrs, err := request[struct{}](c.nc, c.timeout, ", strconv.Quote(subjectName(service, method)), ", ", input, ", nil, opts...)")
				g.P("return serviceErrs, err")
			}
		} else {
			var errReturn = "nil, "
			if method.Output.Location.SourceFile == emptyPb {
				errReturn = ""
			}
			g.P("if err := c.handleWithRetry("+handleReq+", ", strconv.Quote(subjectName(service, method)), ", ", handleResp, ", opts...); err != nil {")
			g.P("return ", errReturn, "err")
			g.P("}")
			g.P("return ", returnResp, "nil")
		}
		g.P("}")
		g.P()
	}

	g.P("//endregion")
	g.P()
	return nil
}

func generateReqFunc(g *protogen.GeneratedFile, cliName, goName, method string, T any, verb micro.Verb) {
	g.P("func (c *", unexport(cliName), ") ", method, "(opts ...", goNatsPkg.Ident("CallOption"), ") ([]*", T, ", error) {")
	g.P("objs, _, err := request(c.nc, c.timeout, ", strconv.Quote(fmt.Sprintf("%s.%s.%s", micro.APIPrefix, verb, goName)), ", nil, func(data []byte, rtt ", timeDuration, ") (*", T, ", error) {")
	g.P("var obj ", T)
	g.P("if err := ", protogen.GoImportPath("encoding/json").Ident("Unmarshal"), "(data, &obj); err != nil {")
	g.P("return nil, err")
	g.P("}")
	if method == "Ping" {
		g.P("obj.RTT = rtt")
	}
	g.P("return &obj, nil")
	g.P("}, opts...)")
	g.P("return objs, err")
	g.P("}")
	g.P()
}

func generateService(g *protogen.GeneratedFile, service *protogen.Service) error {
	if err := generateClient(g, service); err != nil {
		return err
	}
	if err := generateServer(g, service); err != nil {
		return err
	}
	return nil
}

func subjectName(service *protogen.Service, method *protogen.Method) string {
	return "service." + service.GoName + "." + method.GoName
}
