package main

import (
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"strconv"
	"strings"
	gonats_proto "xiam.li/go-nats/proto"
)

const (
	natsPkg   = protogen.GoImportPath("github.com/nats-io/nats.go")
	microPkg  = protogen.GoImportPath("github.com/nats-io/nats.go/micro")
	nuidPkg   = protogen.GoImportPath("github.com/nats-io/nuid")
	timePkg   = protogen.GoImportPath("time")
	slogPkg   = protogen.GoImportPath("log/slog")
	protoPkg  = protogen.GoImportPath("google.golang.org/protobuf/proto")
	goNatsPkg = protogen.GoImportPath("xiam.li/go-nats")
	errorsPkg = protogen.GoImportPath("errors")
)

var (
	natsConn       = natsPkg.Ident("Conn")
	microConfig    = microPkg.Ident("Config")
	microRequest   = microPkg.Ident("Request")
	timeDuration   = timePkg.Ident("Duration")
	debugLogger    = slogPkg.Ident("Debug")
	protoMessage   = protoPkg.Ident("Message")
	protoMarshal   = protoPkg.Ident("Marshal")
	protoUnmarshal = protoPkg.Ident("Unmarshal")

	emptyPb = "google/protobuf/empty.proto"

	// reservedKeywords is a map of reserved keywords that cannot be used as method names
	reservedKeywords = map[string]struct{}{
		"listinstances": {},
		"ping":          {},
		"stats":         {},
		"info":          {},
	}
)

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

func unexport(s string) string { return strings.ToLower(s[:1]) + s[1:] }

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Services) == 0 {
		return
	}
	filename := file.GeneratedFilenamePrefix + "_nats.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-nats. DO NOT EDIT.")
	g.P("// Versions:")
	g.P("// - protoc-gen-go-nats ", version)
	g.P("// - protoc        v", protocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	for _, service := range file.Services {
		generateService(g, service)
	}
}

func isUsingBroadcasting(method *protogen.Method) bool {
	if !proto.HasExtension(method.Desc.Options(), gonats_proto.E_Broadcast) {
		return false
	}
	extension := proto.GetExtension(method.Desc.Options(), gonats_proto.E_Broadcast)
	return extension.(bool)
}

func getConsensusTarget(method *protogen.Method) *gonats_proto.ConsensusTarget {
	if !proto.HasExtension(method.Desc.Options(), gonats_proto.E_ConsensusTarget) {
		return nil
	}
	extension := proto.GetExtension(method.Desc.Options(), gonats_proto.E_ConsensusTarget).(gonats_proto.ConsensusTarget)
	return &extension
}

func generateServer(g *protogen.GeneratedFile, service *protogen.Service) {
	srvName := service.GoName + "NATSServer"

	var leaderMethods, followerMethods []string

	// Generate server interface
	g.P("//region Server")
	g.P("type ", srvName, " interface {")
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			// TODO: Skipping currently unsupported streaming methods for now
			g.P("// ", method.GoName, " is a streaming method and is currently not supported")
			continue
		}
		// Check if method.GoName is in reservedKeywords
		if _, ok := reservedKeywords[strings.ToLower(method.GoName)]; ok {
			g.P("// ", method.GoName, " is a reserved keyword and cannot be used as a method name")
			continue
		}
		var req, resp string
		if method.Input.Location.SourceFile != emptyPb {
			req = "req *" + g.QualifiedGoIdent(method.Input.GoIdent)
		}
		if method.Output.Location.SourceFile != emptyPb {
			resp = "*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", "
		}
		fn := fmt.Sprintf("%s%s(%s) (%serror)", method.Comments.Leading, method.GoName, req, resp)

		consensusTarget := getConsensusTarget(method)
		if consensusTarget != nil {
			g.P("// ", method.GoName, " is a consensus-based method with target ", consensusTarget)
			if *consensusTarget == gonats_proto.ConsensusTarget_LEADER {
				leaderMethods = append(leaderMethods, fn)
				//leaderMethods = append(leaderMethods, []any{method.Comments.Leading, method.GoName, "(", req, ") (", resp, "error)"})
			} else {
				followerMethods = append(followerMethods, fn)
				//followerMethods = append(followerMethods, []any{method.Comments.Leading, method.GoName, "(", req, ") (", resp, "error)"})
			}
		} else {
			g.P(fn)
			//g.P(method.Comments.Leading, method.GoName, "(", req, ") (", resp, "error)")
		}
	}
	if len(leaderMethods) > 0 {
		g.P(service.GoName, "NATSLeaderServer")
	}
	if len(followerMethods) > 0 {
		g.P(service.GoName, "NATSFollowerServer")
	}

	g.P("}")
	g.P()

	// Generate Follower/leader interface if there are any consensus-based methods
	if len(leaderMethods) > 0 {
		g.P("type ", service.GoName, "NATSLeaderServer interface {")
		for _, method := range leaderMethods {
			g.P(method)
		}
		g.P("}")
		g.P()
	}
	if len(followerMethods) > 0 {
		g.P("type ", service.GoName, "NATSFollowerServer interface {")
		for _, method := range followerMethods {
			g.P(method)
		}
		g.P("}")
		g.P()
	}

	// Gen
	g.P("func New", srvName, "(nc *", natsConn, ", impl ", srvName, ", opts ...", goNatsPkg.Ident("ServerOption"), ") ", microPkg.Ident("Service"), " {")
	g.P("service, options, err := ", goNatsPkg.Ident("NewService"), "(", strconv.Quote(service.GoName), ", nc, impl, opts...)")
	g.P("if err != nil {")
	g.P("panic(err) // TODO: Update this to proper error handling")
	g.P("}")
	g.P("_new", service.GoName, "Server(service, impl)")
	g.P()

	if len(leaderMethods) > 0 {
		g.P("if !options.WithoutLeaderFns {")
		g.P("_new", service.GoName, "LeaderServer(service, impl)")
		g.P("}")
	}
	if len(followerMethods) > 0 {
		g.P("if !options.WithoutFollowerFns {")
		g.P("_new", service.GoName, "FollowerServer(service, impl)")
		g.P("}")
	}
	g.P("return service")
	g.P("}")

	g.P("func _new", service.GoName, "Server(service micro.Service, impl ", service.GoName, "NATSServer) {")
	g.P("var err error")
	g.P("_ = err") // In case there are no more methods so that err isn't unused
	g.P()

	// Generate service endpoints
	g.P("// Register the service's methods")
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			// TODO: Skipping currently unsupported streaming methods for now
			continue
		}
		// Check if method.GoName is in reservedKeywords
		if _, ok := reservedKeywords[strings.ToLower(method.GoName)]; ok {
			continue
		}
		if getConsensusTarget(method) != nil {
			continue
		}

		generateEndpointHandler(g, service, method)
	}

	g.P("}")
	g.P()

	if len(leaderMethods) > 0 {
		g.P("func New", service.GoName, "NATSLeaderServer(nc *", natsConn, ", impl ", service.GoName, "NATSLeaderServer, opts ...", goNatsPkg.Ident("ServerOption"), ") ", microPkg.Ident("Service"), " {")
		g.P("service, _, err := ", goNatsPkg.Ident("NewService"), "(", strconv.Quote(service.GoName), ", nc, impl, opts...)")
		g.P("if err != nil {")
		g.P("panic(err) // TODO: Update this to proper error handling")
		g.P("}")
		g.P("_new", service.GoName, "LeaderServer(service, impl)")
		g.P("return service")
		g.P("}")
		g.P()

		g.P("func _new", service.GoName, "LeaderServer(service micro.Service, impl ", service.GoName, "NATSLeaderServer) {")
		g.P("var err error")
		g.P("_ = err") // In case there are no more methods so that err isn't unused

		for _, method := range service.Methods {
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				// TODO: Skipping currently unsupported streaming methods for now
				continue
			}
			// Check if method.GoName is in reservedKeywords
			if _, ok := reservedKeywords[strings.ToLower(method.GoName)]; ok {
				continue
			}
			if target := getConsensusTarget(method); target == nil || *target != gonats_proto.ConsensusTarget_LEADER {
				continue
			}

			generateEndpointHandler(g, service, method)
		}
		g.P("}")
		g.P()
	}

	if len(followerMethods) > 0 {
		g.P("func New", service.GoName, "NATSFollowerServer(nc *", natsConn, ", impl ", service.GoName, "NATSFollowerServer, opts ...", goNatsPkg.Ident("ServerOption"), ") ", microPkg.Ident("Service"), " {")
		g.P("service, _, err := ", goNatsPkg.Ident("NewService"), "(", strconv.Quote(service.GoName), ", nc, impl, opts...)")
		g.P("if err != nil {")
		g.P("panic(err) // TODO: Update this to proper error handling")
		g.P("}")
		g.P("_new", service.GoName, "FollowerServer(service, impl)")
		g.P("return service")
		g.P("}")
		g.P()

		g.P("func _new", service.GoName, "FollowerServer(service micro.Service, impl ", service.GoName, "NATSFollowerServer) {")
		g.P("var err error")
		g.P("_ = err") // In case there are no more methods so that err isn't unused

		for _, method := range service.Methods {
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				// TODO: Skipping currently unsupported streaming methods for now
				continue
			}
			// Check if method.GoName is in reservedKeywords
			if _, ok := reservedKeywords[strings.ToLower(method.GoName)]; ok {
				continue
			}
			if target := getConsensusTarget(method); target == nil || *target != gonats_proto.ConsensusTarget_FOLLOWER {
				continue
			}

			generateEndpointHandler(g, service, method)
		}
		g.P("}")
		g.P()
	}
	g.P("//endregion")
}

func generateEndpointHandler(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) {
	handler := method.GoName + "Handler"
	g.P(handler, " := ", microPkg.Ident("HandlerFunc"), "(func(request ", microRequest, ") {")

	var handlerReq string
	if method.Input.Location.SourceFile != emptyPb {
		handlerReq = "&req"
		g.P("var req ", method.Input.GoIdent)
		g.P("if err := ", protoUnmarshal, "(request.Data(), &req); err != nil {")
		g.P("request.Error(", strconv.Quote("560"), ", ", strconv.Quote("Failed to unmarshal proto message"), ", []byte(err.Error()))")
		g.P("return")
		g.P("}")
		g.P()
	}
	var handlerResp string
	if method.Output.Location.SourceFile != emptyPb {
		handlerResp = "response, "
	}
	g.P(handlerResp, "err := impl.", method.GoName, "(", handlerReq, ")")
	g.P("if err != nil {")
	g.P("var serverErr ", goNatsPkg.Ident("ServerError"))
	g.P("if ", errorsPkg.Ident("As"), "(err, &serverErr) {")
	g.P("request.Error(serverErr.Code, serverErr.Description, serverErr.GetWrapped(), serverErr.GetOptHeaders())")
	g.P("} else {")
	g.P("request.Error(", strconv.Quote("500"), ", ", strconv.Quote("Internal server error"), ", []byte(err.Error()))")
	g.P("}")
	g.P("return")
	g.P("}")
	g.P()
	if method.Output.Location.SourceFile != emptyPb {
		g.P("data, err := ", protoMarshal, "(response)")
		g.P("if err != nil {")
		g.P("request.Error(", strconv.Quote("560"), ", ", strconv.Quote("Failed to marshal proto message"), ", []byte(err.Error()))")
		g.P("return")
		g.P("}")
		g.P("request.Respond(data)")
	} else {
		g.P("request.Respond(nil)")
	}
	g.P("})")

	if isUsingBroadcasting(method) {
		// Add a broadcast endpoint for the method
		g.P("err = service.AddEndpoint(", strconv.Quote(method.GoName+"-Broadcast"), ", ", handler, ", ", microPkg.Ident("WithEndpointQueueGroup"), "(", nuidPkg.Ident("Next"), "()), ", microPkg.Ident("WithEndpointSubject"), "(", strconv.Quote(subjectName(service, method)), "))")
	} else {
		// Add a shared endpoint for the method
		g.P("err = service.AddEndpoint(", strconv.Quote(method.GoName), ", ", handler, ", ", microPkg.Ident("WithEndpointSubject"), "(", strconv.Quote(subjectName(service, method)), "))")
		g.P("if err != nil {")
		g.P("panic(err) // TODO: Update this to proper error handling")
		g.P("}")

		// Add a direct endpoint for the method
		g.P("err = service.AddEndpoint(", strconv.Quote(method.GoName+"-Direct"), ", ", handler, ", ", microPkg.Ident("WithEndpointSubject"), "(", strconv.Quote(subjectName(service, method)+"."), " + service.Info().ID))")
		g.P("if err != nil {")
		g.P("panic(err) // TODO: Update this to proper error handling")
		g.P("}")
	}
	g.P()
}

func generateClient(g *protogen.GeneratedFile, service *protogen.Service) {
	cliName := service.GoName + "NATSClient"

	// Generate client interface
	g.P("//region Client")
	g.AnnotateSymbol(cliName, protogen.Annotation{Location: service.Location}) // TODO: Find out when to annotate symbols
	g.P("type ", cliName, " interface {")
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			// TODO: Skipping currently unsupported streaming methods for now
			g.P("// ", method.GoName, " is a streaming method and is currently not supported")
			continue
		}
		// Check if method.GoName is in reservedKeywords
		if _, ok := reservedKeywords[strings.ToLower(method.GoName)]; ok {
			g.P("// ", method.GoName, " is a reserved keyword and cannot be used as a method name")
			continue
		}
		broadcasting := isUsingBroadcasting(method)
		var req, resp string
		if method.Input.Location.SourceFile != emptyPb {
			req = "req *" + g.QualifiedGoIdent(method.Input.GoIdent) + ", "
		}
		if method.Output.Location.SourceFile != emptyPb {
			var prefix string
			if broadcasting {
				prefix = "[]"
			}
			resp = prefix + "*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", "
		}
		g.AnnotateSymbol(cliName+"."+method.GoName, protogen.Annotation{Location: method.Location})
		if broadcasting {
			g.P(method.Comments.Leading, method.GoName, "(", req, "opts ...", goNatsPkg.Ident("CallOption"), ") (", resp, "[]", goNatsPkg.Ident("ServiceError"), ", error)")
		} else {
			g.P(method.Comments.Leading, method.GoName, "(", req, "opts ...", goNatsPkg.Ident("CallOption"), ") (", resp, "error)")
		}
	}
	g.P("SetTimeout(", timeDuration, ")")
	g.P("// ListInstances returns a list containing all instances of this service")
	g.P("// This is a convenience method that calls ", goNatsPkg.Ident("Ping"), " with no options")
	g.P("ListInstances() ([]*", goNatsPkg.Ident("Ping"), ", error)")
	g.P("// Ping sends a ping to either all instances or a specific instance of this service")
	g.P("Ping(opts ...", goNatsPkg.Ident("CallOption"), ") ([]*", goNatsPkg.Ident("Ping"), ", error)")
	g.P("// Stats returns the stats of either all instances or a specific instance of this service")
	g.P("Stats(opts ...", goNatsPkg.Ident("CallOption"), ") ([]*micro.Stats, error)")
	g.P("// Info returns the info of either all instances or a specific instance of this service")
	g.P("Info(opts ...", goNatsPkg.Ident("CallOption"), ") ([]*micro.Info, error)")
	g.P("}")
	g.P()

	// Generate client struct implementation
	g.P("type ", unexport(cliName), " struct {")
	g.P("nc *", natsConn)
	g.P("timeout ", timeDuration)
	g.P("}")
	g.P()

	// Client struct functions

	// Generate SetTimeout function
	g.P("func (c *", unexport(cliName), ") SetTimeout(timeout ", timeDuration, ") {")
	g.P("c.timeout = timeout")
	g.P("}")
	g.P()

	// Generate ListInstances function
	g.P("func (c *", unexport(cliName), ") ListInstances() ([]*", goNatsPkg.Ident("Ping"), ", error) {")
	g.P("return c.Ping()")
	g.P("}")
	g.P()

	// Generate ",goNatsPkg.Ident("Ping"),"/Stats/Info functions
	generateReqFunc(g, cliName, service.GoName, "Stats", microPkg.Ident("Stats"), microPkg.Ident("StatsVerb"))
	generateReqFunc(g, cliName, service.GoName, "Info", microPkg.Ident("Info"), microPkg.Ident("InfoVerb"))
	generateReqFunc(g, cliName, service.GoName, "Ping", goNatsPkg.Ident("Ping"), microPkg.Ident("PingVerb"))

	// Generate handle with retry function
	g.P("func (c *", unexport(cliName), ") handleWithRetry(req ", protoMessage, ", subject string, out ", protoMessage, ", opts ...", goNatsPkg.Ident("CallOption"), ") (err error) {")
	g.P("options := ", goNatsPkg.Ident("ProcessCallOptions"), "(opts...)")
	g.P("timeout := options.GetTimeoutOr(c.timeout)")
	g.P()
	g.P("var tries int")
	g.P("for {")
	g.P("if options.HasInstanceID() {")
	g.P("err = c.handle(req, subject+", strconv.Quote("."), "+options.GetInstanceID(), out, timeout)")
	g.P("} else {")
	g.P("err = c.handle(req, subject, out, timeout)")
	g.P("}")
	g.P("if err == nil || !errors.Is(err, ", natsPkg.Ident("ErrNoResponders"), ") {")
	g.P("return")
	g.P("}")
	g.P("tries++")
	g.P("if options.RetryContext().Err() != nil {")
	g.P("err = ", errorsPkg.Ident("Join"), "(err, options.RetryContext().Err())")
	g.P("return")
	g.P("}")
	g.P("if !options.ShouldRetry() {")
	g.P("return")
	g.P("}")
	g.P("if tries >= options.MaxRetries() {")
	g.P("err = ", errorsPkg.Ident("New"), "(", strconv.Quote("Failed to call service after max tries: "), "+ err.Error())")
	g.P("return")
	g.P("}")
	g.P("time.Sleep(options.RetryDelay())")
	g.P("}")
	g.P("}")

	// Generate handle function
	g.P("func (c *", unexport(cliName), ") handle(req ", protoMessage, ", subject string, out ", protoMessage, ", timeout ", timeDuration, ") (err error) {")
	g.P("var data []byte")
	g.P("if req != nil {")
	g.P("if data, err = ", protoMarshal, "(req); err != nil {")
	g.P("return ", goNatsPkg.Ident("ErrMarshallingFailed"))
	g.P("}")
	g.P("}")
	g.P("msg, err := c.nc.Request(subject, data, timeout)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("if errMsg, errCode := msg.Header.Get(", microPkg.Ident("ErrorHeader"), "), msg.Header.Get(", microPkg.Ident("ErrorCodeHeader"), "); len(errMsg) > 0 && len(errCode) > 0 {")
	g.P("if len(msg.Data) == 0 {")
	g.P("return ", goNatsPkg.Ident("ServiceError"), "{errCode, errMsg, \"\"}")
	g.P("}")
	g.P("return ", goNatsPkg.Ident("ServiceError"), "{errCode, errMsg, string(msg.Data)}")
	g.P("}")
	g.P("if out != nil {")
	g.P("if err = ", protoUnmarshal, "(msg.Data, out); err != nil {")
	g.P("return ", goNatsPkg.Ident("ErrUnmarshallingFailed"))
	g.P("}")
	g.P("}")
	g.P("return nil")
	g.P("}")
	g.P()

	// Generate request function
	g.P("func request[T any](conn *", natsConn, ", timeout ", timeDuration, ", subject string, data []byte, collector func([]byte, ", timeDuration, ") (*T, error)) ([]*T, []", goNatsPkg.Ident("ServiceError"), ", error) {")
	g.P("ctx, cancel := ", protogen.GoImportPath("context").Ident("WithTimeout"), "(", protogen.GoImportPath("context").Ident("Background"), "(), timeout)")
	g.P("defer cancel()")
	g.P()
	g.P("timer := ", timePkg.Ident("NewTimer"), "(timeout)")
	g.P("go func() {")
	g.P("// Select whatever happens first")
	g.P("select {")
	g.P("// if timer runs out first, cancel the 5 second context")
	g.P("case <-timer.C:")
	g.P("cancel()")
	g.P("// if context is done already, do nothing, maybe stop timer")
	g.P("case <-ctx.Done():")
	g.P("timer.Stop()")
	g.P("return")
	g.P("}")
	g.P("}()")
	g.P("var start ", timePkg.Ident("Time"))
	g.P("res := []*T{}")
	g.P("mu := ", protogen.GoImportPath("sync").Ident("Mutex"), "{}")
	g.P("errCh := make(chan error)")
	g.P("serviceErrs := []", goNatsPkg.Ident("ServiceError"), "{}")
	g.P("sub, err := conn.Subscribe(conn.NewRespInbox(), func(msg *", natsPkg.Ident("Msg"), ") {")
	g.P("mu.Lock()")
	g.P("defer mu.Unlock()")
	g.P()
	g.P("rtt := ", timePkg.Ident("Since"), "(start)")
	g.P("if msg.Header.Get(\"Status\") == \"503\" {")
	g.P("errCh <- ", natsPkg.Ident("ErrNoResponders"))
	g.P("return")
	g.P("}")
	g.P()
	g.P("if errMsg, errCode := msg.Header.Get(", microPkg.Ident("ErrorHeader"), "), msg.Header.Get(", microPkg.Ident("ErrorCodeHeader"), "); len(errMsg) > 0 && len(errCode) > 0 {")
	g.P("if len(msg.Data) == 0 {")
	g.P("serviceErrs = append(serviceErrs, ", goNatsPkg.Ident("ServiceError"), "{Code: errCode, Description: errMsg})")
	g.P("} else {")
	g.P("serviceErrs = append(serviceErrs, ", goNatsPkg.Ident("ServiceError"), "{Code: errCode, Description: errMsg, Details: string(msg.Data)})")
	g.P("}")
	g.P("return")
	g.P("}")
	g.P("if collector != nil {")
	g.P("if col, err := collector(msg.Data, rtt); err != nil {")
	g.P("errCh <- err")
	g.P("} else {")
	g.P("res = append(res, col)")
	g.P("}")
	g.P("}")
	g.P("})")
	g.P("if err != nil {")
	g.P("return nil, nil, err")
	g.P("}")
	g.P("defer sub.Unsubscribe()")
	g.P()
	g.P("start = ", timePkg.Ident("Now"), "()")
	g.P("err = conn.PublishRequest(subject, sub.Subject, data)")
	g.P("if err != nil {")
	g.P("return nil, nil, err")
	g.P("}")
	g.P()
	g.P("select {")
	g.P("case err = <-errCh:")
	g.P("return nil, serviceErrs, err")
	g.P("case <-ctx.Done():")
	g.P("return res, serviceErrs, nil")
	g.P("}")
	g.P("}")
	g.P()

	// Generate NewClient function
	g.P("func New", cliName, "(nc *", natsConn, ") ", cliName, " {")
	g.P("return &", unexport(cliName), "{nc: nc, timeout: ", timePkg.Ident("Second"), " * 5}")
	g.P("}")
	g.P()

	// Generate client methods
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			// TODO: Skipping currently unsupported streaming methods for now
			continue
		}
		// Check if method.GoName is in reservedKeywords
		if _, ok := reservedKeywords[strings.ToLower(method.GoName)]; ok {
			continue
		}
		broadcasting := isUsingBroadcasting(method)

		var req, resp, handleReq, handleResp, returnResp string
		if method.Input.Location.SourceFile != emptyPb {
			req = "req *" + g.QualifiedGoIdent(method.Input.GoIdent) + ", "
			handleReq = "req"
		} else {
			handleReq = "nil"
		}
		if method.Output.Location.SourceFile != emptyPb {
			var prefix string
			if broadcasting {
				prefix = "[]"
			}
			resp = prefix + "*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", "
			handleResp = "&response"
			returnResp = "&response, "
		} else {
			handleResp = "nil"
			returnResp = ""
		}
		if broadcasting {
			g.P("func (c *", unexport(cliName), ") ", method.GoName, "(", req, "opts ...", goNatsPkg.Ident("CallOption"), ") (", resp, "[]", goNatsPkg.Ident("ServiceError"), ", error) {")
		} else {
			g.P("func (c *", unexport(cliName), ") ", method.GoName, "(", req, "opts ...", goNatsPkg.Ident("CallOption"), ") (", resp, "error) {")
		}

		if broadcasting {
			g.P("options := ", goNatsPkg.Ident("ProcessCallOptions"), "(opts...)")
			g.P("timeout := options.GetTimeoutOr(c.timeout)")
			g.P()
		}

		if method.Output.Location.SourceFile != emptyPb && !broadcasting {
			g.P("var response ", method.Output.GoIdent)
			g.P()
		}

		if broadcasting {
			var input string
			if method.Input.Location.SourceFile != emptyPb {
				var returnResp string
				if method.Output.Location.SourceFile != emptyPb {
					returnResp = "nil, "
				}
				g.P("var data []byte")
				g.P("if req != nil {")
				g.P("var err error")
				g.P("if data, err = ", protoMarshal, "(req); err != nil {")
				g.P("return ", returnResp, "nil, ", goNatsPkg.Ident("ErrMarshallingFailed"))
				g.P("}")
				g.P("}")
				input = "data"
			} else {
				input = "nil"
			}

			if method.Output.Location.SourceFile != emptyPb {
				g.P("objs, serviceErrs, err := request(c.nc, timeout, ", strconv.Quote(subjectName(service, method)), ",", input, ", func(data []byte, rtt ", timeDuration, ") (*", method.Output.GoIdent, ", error) {")
				g.P("var obj ", method.Output.GoIdent)
				g.P("if err := ", protoUnmarshal, "(data, &obj); err != nil {")
				g.P("return nil, err")
				g.P("}")
				g.P("return &obj, nil")
				g.P("})")
				g.P("return objs, serviceErrs, err")
			} else {
				g.P("_, serviceErrs, err := request[struct{}](c.nc, timeout, ", strconv.Quote(subjectName(service, method)), ", ", input, ", nil)")
				g.P("return serviceErrs, err")
			}
		} else {
			var errReturn = "nil, "
			if method.Output.Location.SourceFile == emptyPb {
				errReturn = ""
			}
			g.P("if err := c.handleWithRetry("+handleReq+", ", strconv.Quote(subjectName(service, method)), ", ", handleResp, ", opts...); err != nil {")
			g.P("return ", errReturn, "err")
			g.P("}")
			g.P("return ", returnResp, "nil")
		}
		g.P("}")
		g.P()
	}

	g.P("//endregion")
	g.P()
}

func generateReqFunc(g *protogen.GeneratedFile, cliName, goName, method string, T any, verb any) {
	g.P("func (c *", unexport(cliName), ") ", method, "(opts ...", goNatsPkg.Ident("CallOption"), ") ([]*", T, ", error) {")
	g.P("options := ", goNatsPkg.Ident("ProcessCallOptions"), "(opts...)")
	g.P("timeout := options.GetTimeoutOr(c.timeout)")
	g.P()

	g.P("var subject string")
	g.P("if options.HasInstanceID() {")
	g.P("subject = ", protogen.GoImportPath("fmt").Ident("Sprintf"), "(\"%s.%s.%s.%s\", ", microPkg.Ident("APIPrefix"), ", ", verb, ", ", strconv.Quote(goName), ", options.GetInstanceID())")
	g.P("} else {")
	g.P("subject = ", protogen.GoImportPath("fmt").Ident("Sprintf"), "(\"%s.%s.%s\", ", microPkg.Ident("APIPrefix"), ", ", verb, ", ", strconv.Quote(goName), ")")
	g.P("}")

	g.P("objs, _, err := request(c.nc, timeout, subject, nil, func(data []byte, rtt ", timeDuration, ") (*", T, ", error) {")
	g.P("var obj ", T)
	g.P("if err := ", protogen.GoImportPath("encoding/json").Ident("Unmarshal"), "(data, &obj); err != nil {")
	g.P("return nil, err")
	g.P("}")
	if method == "Ping" {
		g.P("obj.RTT = rtt")
	}
	g.P("return &obj, nil")
	g.P("})")
	g.P("return objs, err")
	g.P("}")
	g.P()
}

func generateService(g *protogen.GeneratedFile, service *protogen.Service) {
	generateClient(g, service)
	generateServer(g, service)
}

func subjectName(service *protogen.Service, method *protogen.Method) string {
	return "service." + service.GoName + "." + method.GoName
}
