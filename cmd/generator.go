package main

import (
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"strconv"
	"strings"
	"xiam.li/meta"
)

const (
	natsPkg   = protogen.GoImportPath("github.com/nats-io/nats.go")
	microPkg  = protogen.GoImportPath("github.com/nats-io/nats.go/micro")
	timePkg   = protogen.GoImportPath("time")
	slogPkg   = protogen.GoImportPath("log/slog")
	protoPkg  = protogen.GoImportPath("google.golang.org/protobuf/proto")
	protocPkg = protogen.GoImportPath("gitea.xiam.li/Hydria/protoc-gen-go-nats")
)

var (
	natsConn       = natsPkg.Ident("Conn")
	microConfig    = microPkg.Ident("Config")
	microRequest   = microPkg.Ident("Request")
	timeDuration   = timePkg.Ident("Duration")
	debugLogger    = slogPkg.Ident("Debug")
	protoMessage   = protoPkg.Ident("Message")
	protoMarshal   = protoPkg.Ident("Marshal")
	protoUnmarshal = protoPkg.Ident("Unmarshal")

	protocErrMarshalling   = protocPkg.Ident("ErrMarshallingFailed")
	protocErrUnmarshalling = protocPkg.Ident("ErrUnmarshallingFailed")

	// reservedKeywords is a map of reserved keywords that cannot be used as method names
	reservedKeywords = map[string]struct{}{
		"listinstances": {},
		"ping":          {},
		"stats":         {},
		"info":          {},
	}
)

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

func unexport(s string) string { return strings.ToLower(s[:1]) + s[1:] }

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Services) == 0 {
		return
	}
	filename := file.GeneratedFilenamePrefix + "_nats.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-nats. DO NOT EDIT.")
	g.P("// Versions:")
	g.P("// - protoc-gen-go-nats ", meta.VersionOr("v0.0.0-dev+dirty"))
	g.P("// - protoc        v", protocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	for _, service := range file.Services {
		generateService(g, service)
	}
}

func generateServer(g *protogen.GeneratedFile, service *protogen.Service) {
	srvName := service.GoName + "NATSServer"

	// Generate server interface
	g.P("//region Server")
	g.P("type ", srvName, " interface {")
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			// TODO: Skipping currently unsupported streaming methods for now
			g.P("// ", method.GoName, " is a streaming method and is currently not supported")
			continue
		}
		// Check if method.GoName is in reservedKeywords
		if _, ok := reservedKeywords[strings.ToLower(method.GoName)]; ok {
			g.P("// ", method.GoName, " is a reserved keyword and cannot be used as a method name")
			continue
		}
		g.P(method.Comments.Leading, method.GoName, "(req *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error)")
	}
	g.P("}")
	g.P()

	// Generate server options
	g.P("type ServerOption func(config *", microConfig, ")")

	// Generate server option functions
	for field, typ := range map[string]string{
		"StatsHandler": "StatsHandler",
		"DoneHandler":  "DoneHandler",
		"ErrorHandler": "ErrHandler",
	} {
		g.P("func With", field, "(handler ", microPkg.Ident(typ), ") ServerOption {")
		g.P("return func(config *", microConfig, ") {")
		g.P("config.", field, " = handler")
		g.P("}")
		g.P("}")
		g.P()
	}

	// Generate NewServer function
	g.P("func New", srvName, "(nc *", natsConn, ", impl ", srvName, ", opts ...ServerOption) ", microPkg.Ident("Service"), " {")
	g.P("config := ", microConfig, "{")
	g.P("Name: ", strconv.Quote(service.GoName), ",")
	g.P("Version: ", strconv.Quote("1.0.0"), ",")
	g.P("}")
	g.P()

	g.P("// Check if the service implements any of the handler interfaces")
	g.P("// but do it before applying options, so these can still override the handlers")
	g.P("if statsHandler, isStatsHandler := impl.(", protocPkg.Ident("StatsHandler"), "); isStatsHandler {")
	g.P("config.StatsHandler = statsHandler.Stats")
	g.P(debugLogger, "(\"Service implements StatsHandler; using service's Stats method\")")
	g.P("}")
	g.P("if doneHandler, isDoneHandler := impl.(", protocPkg.Ident("DoneHandler"), "); isDoneHandler {")
	g.P("config.DoneHandler = doneHandler.Done")
	g.P(debugLogger, "(\"Service implements DoneHandler; using service's Done method\")")
	g.P("}")
	g.P("if errHandler, isErrHandler := impl.(", protocPkg.Ident("ErrHandler"), "); isErrHandler {")
	g.P("config.ErrorHandler = errHandler.Err")
	g.P(debugLogger, "(\"Service implements ErrHandler; using service's Err method\")")
	g.P("}")
	g.P()

	g.P("// Apply options")
	g.P("for _, opt := range opts {")
	g.P("opt(&config)")
	g.P("}")
	g.P()
	g.P("// Create the service")
	g.P("service, err := micro.AddService(nc, config)")
	g.P("if err != nil {")
	g.P("panic(err) // TODO: Update this to proper error handling")
	g.P("}")
	g.P()

	// Generate service endpoints
	g.P("// Register the service's methods")
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			// TODO: Skipping currently unsupported streaming methods for now
			continue
		}
		// Check if method.GoName is in reservedKeywords
		if _, ok := reservedKeywords[strings.ToLower(method.GoName)]; ok {
			continue
		}

		handler := method.GoName + "Handler"
		g.P(handler, " := ", microPkg.Ident("HandlerFunc"), "(func(request ", microRequest, ") {")
		g.P("var req ", method.Input.GoIdent)
		g.P("if err := ", protoUnmarshal, "(request.Data(), &req); err != nil {")
		g.P("request.Error(", strconv.Quote("560"), ", ", strconv.Quote("Failed to unmarshal proto message"), ", []byte(err.Error()))")
		g.P("return")
		g.P("}")
		g.P()
		g.P("response, err := impl.", method.GoName, "(&req)")
		g.P("if err != nil {")
		g.P("if natsErr, ok := err.(*", protocPkg.Ident("NATSError"), "); ok {")
		g.P("natsErr.RespondWith(request)")
		g.P("} else {")
		g.P("request.Error(", strconv.Quote("500"), ", ", strconv.Quote("Internal server error"), ", []byte(err.Error()))")
		g.P("}")
		g.P("return")
		g.P("}")
		g.P()
		g.P("data, err := ", protoMarshal, "(response)")
		g.P("if err != nil {")
		g.P("request.Error(", strconv.Quote("560"), ", ", strconv.Quote("Failed to marshal proto message"), ", []byte(err.Error()))")
		g.P("return")
		g.P("}")
		g.P()
		g.P("request.Respond(data)")
		g.P("})")

		g.P("err = service.AddEndpoint(", strconv.Quote(method.GoName), ", ", handler, ", ", microPkg.Ident("WithEndpointSubject"), "(", strconv.Quote(subjectName(service, method)), "))")
		g.P("if err != nil {")
		g.P("panic(err) // TODO: Update this to proper error handling")
		g.P("}")

		g.P("err = service.AddEndpoint(", strconv.Quote(method.GoName+"-Direct"), ", ", handler, ", ", microPkg.Ident("WithEndpointSubject"), "(", strconv.Quote(subjectName(service, method)+"."), " + service.Info().ID))")
		g.P("if err != nil {")
		g.P("panic(err) // TODO: Update this to proper error handling")
		g.P("}")
		g.P()
	}

	g.P("return service")
	g.P("}")
	g.P("//endregion")
}

func generateClient(g *protogen.GeneratedFile, service *protogen.Service) {
	cliName := service.GoName + "NATSClient"

	// Generate client interface
	g.P("//region Client")
	g.AnnotateSymbol(cliName, protogen.Annotation{Location: service.Location}) // TODO: Find out when to annotate symbols
	g.P("type ", cliName, " interface {")
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			// TODO: Skipping currently unsupported streaming methods for now
			g.P("// ", method.GoName, " is a streaming method and is currently not supported")
			continue
		}
		// Check if method.GoName is in reservedKeywords
		if _, ok := reservedKeywords[strings.ToLower(method.GoName)]; ok {
			g.P("// ", method.GoName, " is a reserved keyword and cannot be used as a method name")
			continue
		}
		g.AnnotateSymbol(cliName+"."+method.GoName, protogen.Annotation{Location: method.Location})
		g.P(method.Comments.Leading, method.GoName, "(req *", method.Input.GoIdent, ", opts ...CallOption) (*", method.Output.GoIdent, ", error)")
	}
	g.P("SetTimeout(", timeDuration, ")")
	g.P("// ListInstances returns a list containing all instances of this service")
	g.P("// This is a convenience method that calls Ping with no options")
	g.P("ListInstances() ([]*Ping, error)")
	g.P("// Ping sends a ping to either all instances or a specific instance of this service")
	g.P("Ping(opts ...CallOption) ([]*Ping, error)")
	g.P("// Stats returns the stats of either all instances or a specific instance of this service")
	g.P("Stats(opts ...CallOption) ([]*micro.Stats, error)")
	g.P("// Info returns the info of either all instances or a specific instance of this service")
	g.P("Info(opts ...CallOption) ([]*micro.Info, error)")
	g.P("}")
	g.P()

	// Generate Ping struct
	g.P("type Ping struct {")
	g.P(microPkg.Ident("ServiceIdentity"))
	g.P("Type string")
	g.P("RTT ", timeDuration)
	g.P("}")
	g.P()

	// Generate CallOption type and functions
	g.P("//region CallOptions")
	g.P("type CallOption func(*callOptions)")
	g.P()
	g.P("type callOptions struct {")
	g.P("instanceID string")
	g.P("}")
	g.P()
	g.P("func (opts *callOptions) hasInstanceID() bool {")
	g.P("return opts.instanceID != \"\"")
	g.P("}")
	g.P()
	g.P("func WithInstanceID(id string) CallOption {")
	g.P("return func(opts *callOptions) {")
	g.P("opts.instanceID = id")
	g.P("}")
	g.P("}")
	g.P()
	g.P("func process(opts ...CallOption) callOptions {")
	g.P("options := callOptions{}")
	g.P("for _, opt := range opts {")
	g.P("opt(&options)")
	g.P("}")
	g.P("return options")
	g.P("}")
	g.P("//endregion")
	g.P()

	// Generate client struct implementation
	g.P("type ", unexport(cliName), " struct {")
	g.P("nc *", natsConn)
	g.P("timeout ", timeDuration)
	g.P("}")
	g.P()

	// Client struct functions

	//		Generate SetTimeout function
	g.P("func (c *", unexport(cliName), ") SetTimeout(timeout ", timeDuration, ") {")
	g.P("c.timeout = timeout")
	g.P("}")
	g.P()

	//		Generate ListInstances function
	g.P("func (c *", unexport(cliName), ") ListInstances() ([]*Ping, error) {")
	g.P("return c.Ping()")
	g.P("}")
	g.P()

	// Generate Ping/Stats/Info functions
	generateReqFunc(g, cliName, service.GoName, "Stats", microPkg.Ident("Stats"), microPkg.Ident("StatsVerb"))
	generateReqFunc(g, cliName, service.GoName, "Info", microPkg.Ident("Info"), microPkg.Ident("InfoVerb"))
	generateReqFunc(g, cliName, service.GoName, "Ping", "Ping", microPkg.Ident("PingVerb"))

	// 		Generate handle function
	g.P("func (c *", unexport(cliName), ") handle(req ", protoMessage, ", subject string, out ", protoMessage, ") error {")
	g.P("data, err := ", protoMarshal, "(req)")
	g.P("if err != nil {")
	g.P("return ", protocErrMarshalling)
	g.P("}")
	g.P("msg, err := c.nc.Request(subject, data, c.timeout)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("if err := ", protoUnmarshal, "(msg.Data, out); err != nil {")
	g.P("return ", protocErrUnmarshalling)
	g.P("}")
	g.P("return nil")
	g.P("}")
	g.P()

	// Generate request function
	g.P("func request[T any](conn *", natsConn, ", timeout ", timeDuration, ", subject string, collector func([]byte, ", timeDuration, ") (*T, error)) ([]*T, error) {")
	g.P("ctx, cancel := ", protogen.GoImportPath("context").Ident("WithTimeout"), "(", protogen.GoImportPath("context").Ident("Background"), "(), timeout)")
	g.P("defer cancel()")
	g.P()
	g.P("timer := ", timePkg.Ident("NewTimer"), "(timeout)")
	g.P("go func() {")
	g.P("// Select whatever happens first")
	g.P("select {")
	g.P("// if timer runs out first, cancel the 5 second context")
	g.P("case <-timer.C:")
	g.P("cancel()")
	g.P("// if context is done already, do nothing, maybe stop timer")
	g.P("case <-ctx.Done():")
	g.P("timer.Stop()")
	g.P("return")
	g.P("}")
	g.P("}()")
	g.P("var start ", timePkg.Ident("Time"))
	g.P("res := []*T{}")
	g.P("mu := ", protogen.GoImportPath("sync").Ident("Mutex"), "{}")
	g.P("errs := make(chan error)")
	g.P("sub, err := conn.Subscribe(conn.NewRespInbox(), func(msg *", natsPkg.Ident("Msg"), ") {")
	g.P("mu.Lock()")
	g.P("defer mu.Unlock()")
	g.P()
	g.P("rtt := ", timePkg.Ident("Since"), "(start)")
	g.P("if msg.Header.Get(\"Status\") == \"503\" {")
	g.P("errs <- ", natsPkg.Ident("ErrNoResponders"))
	g.P("return")
	g.P("}")
	g.P()
	g.P("timer.Reset(300 * ", timePkg.Ident("Millisecond"), ")")
	g.P("if col, err := collector(msg.Data, rtt); err != nil {")
	g.P("errs <- err")
	g.P("} else {")
	g.P("res = append(res, col)")
	g.P("}")
	g.P("})")
	g.P("if err != nil {")
	g.P("return nil, err")
	g.P("}")
	g.P("defer sub.Unsubscribe()")
	g.P()
	g.P("start = ", timePkg.Ident("Now"), "()")
	g.P("err = conn.PublishRequest(subject, sub.Subject, nil)")
	g.P("if err != nil {")
	g.P("return nil, err")
	g.P("}")
	g.P()
	g.P("select {")
	g.P("case err = <-errs:")
	g.P("return nil, err")
	g.P("case <-ctx.Done():")
	g.P("}")
	g.P()
	g.P("return res, nil")
	g.P("}")
	g.P()

	// Generate NewClient function
	g.P("func New", cliName, "(nc *", natsConn, ") ", cliName, " {")
	g.P("return &", unexport(cliName), "{nc: nc, timeout: ", timePkg.Ident("Second"), " * 5}")
	g.P("}")
	g.P()

	// Generate client methods
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			// TODO: Skipping currently unsupported streaming methods for now
			continue
		}
		// Check if method.GoName is in reservedKeywords
		if _, ok := reservedKeywords[strings.ToLower(method.GoName)]; ok {
			continue
		}

		g.P("func (c *", unexport(cliName), ") ", method.GoName, "(req *", method.Input.GoIdent, ", opts ...CallOption) (*", method.Output.GoIdent, ", error) {")
		g.P("options := process(opts...)")
		g.P("var response ", method.Output.GoIdent)
		g.P("var err error")
		g.P()
		g.P("if options.hasInstanceID() {")
		g.P("err = c.handle(req, ", strconv.Quote(subjectName(service, method)+"."), " + options.instanceID, &response)")
		g.P("} else {")
		g.P("err = c.handle(req, ", strconv.Quote(subjectName(service, method)), ", &response)")
		g.P("}")
		g.P("return &response, err")
		g.P("}")
		g.P()
	}

	g.P("//endregion")
	g.P()
}

func generateReqFunc(g *protogen.GeneratedFile, cliName, goName, method string, T any, verb any) {
	g.P("func (c *", unexport(cliName), ") ", method, "(opts ...CallOption) ([]*", T, ", error) {")
	g.P("options := process(opts...)")
	g.P("var subject string")
	g.P()
	g.P("if options.hasInstanceID() {")
	g.P("subject = ", protogen.GoImportPath("fmt").Ident("Sprintf"), "(\"%s.%s.%s.%s\", ", microPkg.Ident("APIPrefix"), ", ", verb, ", ", strconv.Quote(goName), ", options.instanceID)")
	g.P("} else {")
	g.P("subject = ", protogen.GoImportPath("fmt").Ident("Sprintf"), "(\"%s.%s.%s\", ", microPkg.Ident("APIPrefix"), ", ", verb, ", ", strconv.Quote(goName), ")")
	g.P("}")

	g.P("objs, err := request(c.nc, c.timeout, subject, func(data []byte, rtt ", timeDuration, ") (*", T, ", error) {")
	g.P("var obj ", T)
	g.P("if err := ", protogen.GoImportPath("encoding/json").Ident("Unmarshal"), "(data, &obj); err != nil {")
	g.P("return nil, err")
	g.P("}")
	if method == "Ping" {
		g.P("obj.RTT = rtt")
	}
	g.P("return &obj, nil")
	g.P("})")
	g.P("if err != nil {")
	g.P("return nil, err")
	g.P("}")
	g.P("return objs, nil")
	g.P("}")
	g.P()
}

func generateService(g *protogen.GeneratedFile, service *protogen.Service) {
	generateClient(g, service)
	generateServer(g, service)
}

func subjectName(service *protogen.Service, method *protogen.Method) string {
	return service.GoName + "." + method.GoName
}
